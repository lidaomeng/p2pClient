/* soapC.cpp
   Generated by gSOAP 2.8.14 from fctxt.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under ONE of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.14 2016-03-29 04:15:25 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__getExceptionReportResponse:
		return soap_in_ns1__getExceptionReportResponse(soap, NULL, NULL, "ns1:getExceptionReportResponse");
	case SOAP_TYPE_ns1__getExceptionReport:
		return soap_in_ns1__getExceptionReport(soap, NULL, NULL, "ns1:getExceptionReport");
	case SOAP_TYPE_ns1__getDcpResponse:
		return soap_in_ns1__getDcpResponse(soap, NULL, NULL, "ns1:getDcpResponse");
	case SOAP_TYPE_ns1__getDcp:
		return soap_in_ns1__getDcp(soap, NULL, NULL, "ns1:getDcp");
	case SOAP_TYPE_ns1__getPackListResponse:
		return soap_in_ns1__getPackListResponse(soap, NULL, NULL, "ns1:getPackListResponse");
	case SOAP_TYPE_ns1__getPackList:
		return soap_in_ns1__getPackList(soap, NULL, NULL, "ns1:getPackList");
	case SOAP_TYPE_ns1__sendTaskProcessResponse:
		return soap_in_ns1__sendTaskProcessResponse(soap, NULL, NULL, "ns1:sendTaskProcessResponse");
	case SOAP_TYPE_ns1__sendTaskProcess:
		return soap_in_ns1__sendTaskProcess(soap, NULL, NULL, "ns1:sendTaskProcess");
	case SOAP_TYPE_ns1__getTaskProcessReportResponse:
		return soap_in_ns1__getTaskProcessReportResponse(soap, NULL, NULL, "ns1:getTaskProcessReportResponse");
	case SOAP_TYPE_ns1__getTaskProcessReport:
		return soap_in_ns1__getTaskProcessReport(soap, NULL, NULL, "ns1:getTaskProcessReport");
	case SOAP_TYPE_ns1__SQLException:
		return soap_in_ns1__SQLException(soap, NULL, NULL, "ns1:SQLException");
	case SOAP_TYPE_ns1__TaskExceptionReport:
		return soap_in_ns1__TaskExceptionReport(soap, NULL, NULL, "ns1:TaskExceptionReport");
	case SOAP_TYPE_ns1__dcpDetailBean:
		return soap_in_ns1__dcpDetailBean(soap, NULL, NULL, "ns1:dcpDetailBean");
	case SOAP_TYPE_ns1__dcpBean:
		return soap_in_ns1__dcpBean(soap, NULL, NULL, "ns1:dcpBean");
	case SOAP_TYPE_ns1__TaskOper:
		return soap_in_ns1__TaskOper(soap, NULL, NULL, "ns1:TaskOper");
	case SOAP_TYPE_ns1__arrayList:
		return soap_in_ns1__arrayList(soap, NULL, NULL, "ns1:arrayList");
	case SOAP_TYPE_ns1__abstractList:
		return soap_in_ns1__abstractList(soap, NULL, NULL, "ns1:abstractList");
	case SOAP_TYPE_ns1__abstractCollection:
		return soap_in_ns1__abstractCollection(soap, NULL, NULL, "ns1:abstractCollection");
	case SOAP_TYPE_ns1__TaskInfo:
		return soap_in_ns1__TaskInfo(soap, NULL, NULL, "ns1:TaskInfo");
	case SOAP_TYPE_ns1__TaskProgress:
		return soap_in_ns1__TaskProgress(soap, NULL, NULL, "ns1:TaskProgress");
	case SOAP_TYPE_ns1__TaskProcessReport:
		return soap_in_ns1__TaskProcessReport(soap, NULL, NULL, "ns1:TaskProcessReport");
	case SOAP_TYPE_PointerTons1__getExceptionReportResponse:
		return soap_in_PointerTons1__getExceptionReportResponse(soap, NULL, NULL, "ns1:getExceptionReportResponse");
	case SOAP_TYPE_PointerTons1__getExceptionReport:
		return soap_in_PointerTons1__getExceptionReport(soap, NULL, NULL, "ns1:getExceptionReport");
	case SOAP_TYPE_PointerTons1__getDcpResponse:
		return soap_in_PointerTons1__getDcpResponse(soap, NULL, NULL, "ns1:getDcpResponse");
	case SOAP_TYPE_PointerTons1__getDcp:
		return soap_in_PointerTons1__getDcp(soap, NULL, NULL, "ns1:getDcp");
	case SOAP_TYPE_PointerTons1__sendTaskProcessResponse:
		return soap_in_PointerTons1__sendTaskProcessResponse(soap, NULL, NULL, "ns1:sendTaskProcessResponse");
	case SOAP_TYPE_PointerTons1__sendTaskProcess:
		return soap_in_PointerTons1__sendTaskProcess(soap, NULL, NULL, "ns1:sendTaskProcess");
	case SOAP_TYPE_PointerTons1__getPackListResponse:
		return soap_in_PointerTons1__getPackListResponse(soap, NULL, NULL, "ns1:getPackListResponse");
	case SOAP_TYPE_PointerTons1__getPackList:
		return soap_in_PointerTons1__getPackList(soap, NULL, NULL, "ns1:getPackList");
	case SOAP_TYPE_PointerTons1__getTaskProcessReportResponse:
		return soap_in_PointerTons1__getTaskProcessReportResponse(soap, NULL, NULL, "ns1:getTaskProcessReportResponse");
	case SOAP_TYPE_PointerTons1__getTaskProcessReport:
		return soap_in_PointerTons1__getTaskProcessReport(soap, NULL, NULL, "ns1:getTaskProcessReport");
	case SOAP_TYPE_PointerTons1__SQLException:
		return soap_in_PointerTons1__SQLException(soap, NULL, NULL, "ns1:SQLException");
	case SOAP_TYPE_PointerTons1__TaskExceptionReport:
		return soap_in_PointerTons1__TaskExceptionReport(soap, NULL, NULL, "ns1:TaskExceptionReport");
	case SOAP_TYPE_PointerTons1__dcpBean:
		return soap_in_PointerTons1__dcpBean(soap, NULL, NULL, "ns1:dcpBean");
	case SOAP_TYPE_PointerTons1__TaskOper:
		return soap_in_PointerTons1__TaskOper(soap, NULL, NULL, "ns1:TaskOper");
	case SOAP_TYPE_PointerTons1__TaskProcessReport:
		return soap_in_PointerTons1__TaskProcessReport(soap, NULL, NULL, "ns1:TaskProcessReport");
	case SOAP_TYPE_PointerTons1__dcpDetailBean:
		return soap_in_PointerTons1__dcpDetailBean(soap, NULL, NULL, "ns1:dcpDetailBean");
	case SOAP_TYPE_PointerTons1__TaskInfo:
		return soap_in_PointerTons1__TaskInfo(soap, NULL, NULL, "ns1:TaskInfo");
	case SOAP_TYPE_PointerTons1__TaskProgress:
		return soap_in_PointerTons1__TaskProgress(soap, NULL, NULL, "ns1:TaskProgress");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getExceptionReportResponse"))
		{	*type = SOAP_TYPE_ns1__getExceptionReportResponse;
			return soap_in_ns1__getExceptionReportResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getExceptionReport"))
		{	*type = SOAP_TYPE_ns1__getExceptionReport;
			return soap_in_ns1__getExceptionReport(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDcpResponse"))
		{	*type = SOAP_TYPE_ns1__getDcpResponse;
			return soap_in_ns1__getDcpResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDcp"))
		{	*type = SOAP_TYPE_ns1__getDcp;
			return soap_in_ns1__getDcp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPackListResponse"))
		{	*type = SOAP_TYPE_ns1__getPackListResponse;
			return soap_in_ns1__getPackListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPackList"))
		{	*type = SOAP_TYPE_ns1__getPackList;
			return soap_in_ns1__getPackList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sendTaskProcessResponse"))
		{	*type = SOAP_TYPE_ns1__sendTaskProcessResponse;
			return soap_in_ns1__sendTaskProcessResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sendTaskProcess"))
		{	*type = SOAP_TYPE_ns1__sendTaskProcess;
			return soap_in_ns1__sendTaskProcess(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTaskProcessReportResponse"))
		{	*type = SOAP_TYPE_ns1__getTaskProcessReportResponse;
			return soap_in_ns1__getTaskProcessReportResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getTaskProcessReport"))
		{	*type = SOAP_TYPE_ns1__getTaskProcessReport;
			return soap_in_ns1__getTaskProcessReport(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SQLException"))
		{	*type = SOAP_TYPE_ns1__SQLException;
			return soap_in_ns1__SQLException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TaskExceptionReport"))
		{	*type = SOAP_TYPE_ns1__TaskExceptionReport;
			return soap_in_ns1__TaskExceptionReport(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:dcpDetailBean"))
		{	*type = SOAP_TYPE_ns1__dcpDetailBean;
			return soap_in_ns1__dcpDetailBean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:dcpBean"))
		{	*type = SOAP_TYPE_ns1__dcpBean;
			return soap_in_ns1__dcpBean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TaskOper"))
		{	*type = SOAP_TYPE_ns1__TaskOper;
			return soap_in_ns1__TaskOper(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:arrayList"))
		{	*type = SOAP_TYPE_ns1__arrayList;
			return soap_in_ns1__arrayList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:abstractList"))
		{	*type = SOAP_TYPE_ns1__abstractList;
			return soap_in_ns1__abstractList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:abstractCollection"))
		{	*type = SOAP_TYPE_ns1__abstractCollection;
			return soap_in_ns1__abstractCollection(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TaskInfo"))
		{	*type = SOAP_TYPE_ns1__TaskInfo;
			return soap_in_ns1__TaskInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TaskProgress"))
		{	*type = SOAP_TYPE_ns1__TaskProgress;
			return soap_in_ns1__TaskProgress(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TaskProcessReport"))
		{	*type = SOAP_TYPE_ns1__TaskProcessReport;
			return soap_in_ns1__TaskProcessReport(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns1__getExceptionReportResponse:
		return ((ns1__getExceptionReportResponse *)ptr)->soap_out(soap, tag, id, "ns1:getExceptionReportResponse");
	case SOAP_TYPE_ns1__getExceptionReport:
		return ((ns1__getExceptionReport *)ptr)->soap_out(soap, tag, id, "ns1:getExceptionReport");
	case SOAP_TYPE_ns1__getDcpResponse:
		return ((ns1__getDcpResponse *)ptr)->soap_out(soap, tag, id, "ns1:getDcpResponse");
	case SOAP_TYPE_ns1__getDcp:
		return ((ns1__getDcp *)ptr)->soap_out(soap, tag, id, "ns1:getDcp");
	case SOAP_TYPE_ns1__getPackListResponse:
		return ((ns1__getPackListResponse *)ptr)->soap_out(soap, tag, id, "ns1:getPackListResponse");
	case SOAP_TYPE_ns1__getPackList:
		return ((ns1__getPackList *)ptr)->soap_out(soap, tag, id, "ns1:getPackList");
	case SOAP_TYPE_ns1__sendTaskProcessResponse:
		return ((ns1__sendTaskProcessResponse *)ptr)->soap_out(soap, tag, id, "ns1:sendTaskProcessResponse");
	case SOAP_TYPE_ns1__sendTaskProcess:
		return ((ns1__sendTaskProcess *)ptr)->soap_out(soap, tag, id, "ns1:sendTaskProcess");
	case SOAP_TYPE_ns1__getTaskProcessReportResponse:
		return ((ns1__getTaskProcessReportResponse *)ptr)->soap_out(soap, tag, id, "ns1:getTaskProcessReportResponse");
	case SOAP_TYPE_ns1__getTaskProcessReport:
		return ((ns1__getTaskProcessReport *)ptr)->soap_out(soap, tag, id, "ns1:getTaskProcessReport");
	case SOAP_TYPE_ns1__SQLException:
		return ((ns1__SQLException *)ptr)->soap_out(soap, tag, id, "ns1:SQLException");
	case SOAP_TYPE_ns1__TaskExceptionReport:
		return ((ns1__TaskExceptionReport *)ptr)->soap_out(soap, tag, id, "ns1:TaskExceptionReport");
	case SOAP_TYPE_ns1__dcpDetailBean:
		return ((ns1__dcpDetailBean *)ptr)->soap_out(soap, tag, id, "ns1:dcpDetailBean");
	case SOAP_TYPE_ns1__dcpBean:
		return ((ns1__dcpBean *)ptr)->soap_out(soap, tag, id, "ns1:dcpBean");
	case SOAP_TYPE_ns1__TaskOper:
		return ((ns1__TaskOper *)ptr)->soap_out(soap, tag, id, "ns1:TaskOper");
	case SOAP_TYPE_ns1__arrayList:
		return ((ns1__arrayList *)ptr)->soap_out(soap, tag, id, "ns1:arrayList");
	case SOAP_TYPE_ns1__abstractList:
		return ((ns1__abstractList *)ptr)->soap_out(soap, tag, id, "ns1:abstractList");
	case SOAP_TYPE_ns1__abstractCollection:
		return ((ns1__abstractCollection *)ptr)->soap_out(soap, tag, id, "ns1:abstractCollection");
	case SOAP_TYPE_ns1__TaskInfo:
		return ((ns1__TaskInfo *)ptr)->soap_out(soap, tag, id, "ns1:TaskInfo");
	case SOAP_TYPE_ns1__TaskProgress:
		return ((ns1__TaskProgress *)ptr)->soap_out(soap, tag, id, "ns1:TaskProgress");
	case SOAP_TYPE_ns1__TaskProcessReport:
		return ((ns1__TaskProcessReport *)ptr)->soap_out(soap, tag, id, "ns1:TaskProcessReport");
	case SOAP_TYPE_PointerTons1__getExceptionReportResponse:
		return soap_out_PointerTons1__getExceptionReportResponse(soap, tag, id, (ns1__getExceptionReportResponse *const*)ptr, "ns1:getExceptionReportResponse");
	case SOAP_TYPE_PointerTons1__getExceptionReport:
		return soap_out_PointerTons1__getExceptionReport(soap, tag, id, (ns1__getExceptionReport *const*)ptr, "ns1:getExceptionReport");
	case SOAP_TYPE_PointerTons1__getDcpResponse:
		return soap_out_PointerTons1__getDcpResponse(soap, tag, id, (ns1__getDcpResponse *const*)ptr, "ns1:getDcpResponse");
	case SOAP_TYPE_PointerTons1__getDcp:
		return soap_out_PointerTons1__getDcp(soap, tag, id, (ns1__getDcp *const*)ptr, "ns1:getDcp");
	case SOAP_TYPE_PointerTons1__sendTaskProcessResponse:
		return soap_out_PointerTons1__sendTaskProcessResponse(soap, tag, id, (ns1__sendTaskProcessResponse *const*)ptr, "ns1:sendTaskProcessResponse");
	case SOAP_TYPE_PointerTons1__sendTaskProcess:
		return soap_out_PointerTons1__sendTaskProcess(soap, tag, id, (ns1__sendTaskProcess *const*)ptr, "ns1:sendTaskProcess");
	case SOAP_TYPE_PointerTons1__getPackListResponse:
		return soap_out_PointerTons1__getPackListResponse(soap, tag, id, (ns1__getPackListResponse *const*)ptr, "ns1:getPackListResponse");
	case SOAP_TYPE_PointerTons1__getPackList:
		return soap_out_PointerTons1__getPackList(soap, tag, id, (ns1__getPackList *const*)ptr, "ns1:getPackList");
	case SOAP_TYPE_PointerTons1__getTaskProcessReportResponse:
		return soap_out_PointerTons1__getTaskProcessReportResponse(soap, tag, id, (ns1__getTaskProcessReportResponse *const*)ptr, "ns1:getTaskProcessReportResponse");
	case SOAP_TYPE_PointerTons1__getTaskProcessReport:
		return soap_out_PointerTons1__getTaskProcessReport(soap, tag, id, (ns1__getTaskProcessReport *const*)ptr, "ns1:getTaskProcessReport");
	case SOAP_TYPE_PointerTons1__SQLException:
		return soap_out_PointerTons1__SQLException(soap, tag, id, (ns1__SQLException *const*)ptr, "ns1:SQLException");
	case SOAP_TYPE_PointerTons1__TaskExceptionReport:
		return soap_out_PointerTons1__TaskExceptionReport(soap, tag, id, (ns1__TaskExceptionReport *const*)ptr, "ns1:TaskExceptionReport");
	case SOAP_TYPE_PointerTons1__dcpBean:
		return soap_out_PointerTons1__dcpBean(soap, tag, id, (ns1__dcpBean *const*)ptr, "ns1:dcpBean");
	case SOAP_TYPE_PointerTons1__TaskOper:
		return soap_out_PointerTons1__TaskOper(soap, tag, id, (ns1__TaskOper *const*)ptr, "ns1:TaskOper");
	case SOAP_TYPE_PointerTons1__TaskProcessReport:
		return soap_out_PointerTons1__TaskProcessReport(soap, tag, id, (ns1__TaskProcessReport *const*)ptr, "ns1:TaskProcessReport");
	case SOAP_TYPE_PointerTons1__dcpDetailBean:
		return soap_out_PointerTons1__dcpDetailBean(soap, tag, id, (ns1__dcpDetailBean *const*)ptr, "ns1:dcpDetailBean");
	case SOAP_TYPE_PointerTons1__TaskInfo:
		return soap_out_PointerTons1__TaskInfo(soap, tag, id, (ns1__TaskInfo *const*)ptr, "ns1:TaskInfo");
	case SOAP_TYPE_PointerTons1__TaskProgress:
		return soap_out_PointerTons1__TaskProgress(soap, tag, id, (ns1__TaskProgress *const*)ptr, "ns1:TaskProgress");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__getExceptionReportResponse:
		((ns1__getExceptionReportResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getExceptionReport:
		((ns1__getExceptionReport *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getDcpResponse:
		((ns1__getDcpResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getDcp:
		((ns1__getDcp *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getPackListResponse:
		((ns1__getPackListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getPackList:
		((ns1__getPackList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__sendTaskProcessResponse:
		((ns1__sendTaskProcessResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__sendTaskProcess:
		((ns1__sendTaskProcess *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getTaskProcessReportResponse:
		((ns1__getTaskProcessReportResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getTaskProcessReport:
		((ns1__getTaskProcessReport *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SQLException:
		((ns1__SQLException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TaskExceptionReport:
		((ns1__TaskExceptionReport *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__dcpDetailBean:
		((ns1__dcpDetailBean *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__dcpBean:
		((ns1__dcpBean *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TaskOper:
		((ns1__TaskOper *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__arrayList:
		((ns1__arrayList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__abstractList:
		((ns1__abstractList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__abstractCollection:
		((ns1__abstractCollection *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TaskInfo:
		((ns1__TaskInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TaskProgress:
		((ns1__TaskProgress *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TaskProcessReport:
		((ns1__TaskProcessReport *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__getExceptionReport:
		soap_serialize___ns1__getExceptionReport(soap, (const struct __ns1__getExceptionReport *)ptr);
		break;
	case SOAP_TYPE___ns1__getDcp:
		soap_serialize___ns1__getDcp(soap, (const struct __ns1__getDcp *)ptr);
		break;
	case SOAP_TYPE___ns1__sendTaskProcess:
		soap_serialize___ns1__sendTaskProcess(soap, (const struct __ns1__sendTaskProcess *)ptr);
		break;
	case SOAP_TYPE___ns1__getPackList:
		soap_serialize___ns1__getPackList(soap, (const struct __ns1__getPackList *)ptr);
		break;
	case SOAP_TYPE___ns1__getTaskProcessReport:
		soap_serialize___ns1__getTaskProcessReport(soap, (const struct __ns1__getTaskProcessReport *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getExceptionReportResponse:
		soap_serialize_PointerTons1__getExceptionReportResponse(soap, (ns1__getExceptionReportResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getExceptionReport:
		soap_serialize_PointerTons1__getExceptionReport(soap, (ns1__getExceptionReport *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getDcpResponse:
		soap_serialize_PointerTons1__getDcpResponse(soap, (ns1__getDcpResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getDcp:
		soap_serialize_PointerTons1__getDcp(soap, (ns1__getDcp *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__sendTaskProcessResponse:
		soap_serialize_PointerTons1__sendTaskProcessResponse(soap, (ns1__sendTaskProcessResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__sendTaskProcess:
		soap_serialize_PointerTons1__sendTaskProcess(soap, (ns1__sendTaskProcess *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getPackListResponse:
		soap_serialize_PointerTons1__getPackListResponse(soap, (ns1__getPackListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getPackList:
		soap_serialize_PointerTons1__getPackList(soap, (ns1__getPackList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getTaskProcessReportResponse:
		soap_serialize_PointerTons1__getTaskProcessReportResponse(soap, (ns1__getTaskProcessReportResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getTaskProcessReport:
		soap_serialize_PointerTons1__getTaskProcessReport(soap, (ns1__getTaskProcessReport *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SQLException:
		soap_serialize_PointerTons1__SQLException(soap, (ns1__SQLException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TaskExceptionReport:
		soap_serialize_PointerTons1__TaskExceptionReport(soap, (ns1__TaskExceptionReport *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__dcpBean:
		soap_serialize_PointerTons1__dcpBean(soap, (ns1__dcpBean *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TaskOper:
		soap_serialize_PointerTons1__TaskOper(soap, (ns1__TaskOper *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TaskProcessReport:
		soap_serialize_PointerTons1__TaskProcessReport(soap, (ns1__TaskProcessReport *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__dcpDetailBean:
		soap_serialize_PointerTons1__dcpDetailBean(soap, (ns1__dcpDetailBean *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TaskInfo:
		soap_serialize_PointerTons1__TaskInfo(soap, (ns1__TaskInfo *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TaskProgress:
		soap_serialize_PointerTons1__TaskProgress(soap, (ns1__TaskProgress *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TaskProcessReport:
		return (void*)soap_instantiate_ns1__TaskProcessReport(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TaskProgress:
		return (void*)soap_instantiate_ns1__TaskProgress(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TaskInfo:
		return (void*)soap_instantiate_ns1__TaskInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__abstractCollection:
		return (void*)soap_instantiate_ns1__abstractCollection(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TaskOper:
		return (void*)soap_instantiate_ns1__TaskOper(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__dcpBean:
		return (void*)soap_instantiate_ns1__dcpBean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__dcpDetailBean:
		return (void*)soap_instantiate_ns1__dcpDetailBean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TaskExceptionReport:
		return (void*)soap_instantiate_ns1__TaskExceptionReport(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SQLException:
		return (void*)soap_instantiate_ns1__SQLException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTaskProcessReport:
		return (void*)soap_instantiate_ns1__getTaskProcessReport(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getTaskProcessReportResponse:
		return (void*)soap_instantiate_ns1__getTaskProcessReportResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__sendTaskProcess:
		return (void*)soap_instantiate_ns1__sendTaskProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__sendTaskProcessResponse:
		return (void*)soap_instantiate_ns1__sendTaskProcessResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPackList:
		return (void*)soap_instantiate_ns1__getPackList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPackListResponse:
		return (void*)soap_instantiate_ns1__getPackListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDcp:
		return (void*)soap_instantiate_ns1__getDcp(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDcpResponse:
		return (void*)soap_instantiate_ns1__getDcpResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getExceptionReport:
		return (void*)soap_instantiate_ns1__getExceptionReport(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getExceptionReportResponse:
		return (void*)soap_instantiate_ns1__getExceptionReportResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__abstractList:
		return (void*)soap_instantiate_ns1__abstractList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__arrayList:
		return (void*)soap_instantiate_ns1__arrayList(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___ns1__getTaskProcessReport:
		return (void*)soap_instantiate___ns1__getTaskProcessReport(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPackList:
		return (void*)soap_instantiate___ns1__getPackList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__sendTaskProcess:
		return (void*)soap_instantiate___ns1__sendTaskProcess(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getDcp:
		return (void*)soap_instantiate___ns1__getDcp(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getExceptionReport:
		return (void*)soap_instantiate___ns1__getExceptionReport(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__dcpDetailBean:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__dcpDetailBean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaskInfo:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__TaskInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaskProgress:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__TaskProgress(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns1__TaskProcessReport:
		if (p->size < 0)
			SOAP_DELETE((ns1__TaskProcessReport*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__TaskProcessReport*)p->ptr);
		break;
	case SOAP_TYPE_ns1__TaskProgress:
		if (p->size < 0)
			SOAP_DELETE((ns1__TaskProgress*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__TaskProgress*)p->ptr);
		break;
	case SOAP_TYPE_ns1__TaskInfo:
		if (p->size < 0)
			SOAP_DELETE((ns1__TaskInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__TaskInfo*)p->ptr);
		break;
	case SOAP_TYPE_ns1__abstractCollection:
		if (p->size < 0)
			SOAP_DELETE((ns1__abstractCollection*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__abstractCollection*)p->ptr);
		break;
	case SOAP_TYPE_ns1__TaskOper:
		if (p->size < 0)
			SOAP_DELETE((ns1__TaskOper*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__TaskOper*)p->ptr);
		break;
	case SOAP_TYPE_ns1__dcpBean:
		if (p->size < 0)
			SOAP_DELETE((ns1__dcpBean*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__dcpBean*)p->ptr);
		break;
	case SOAP_TYPE_ns1__dcpDetailBean:
		if (p->size < 0)
			SOAP_DELETE((ns1__dcpDetailBean*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__dcpDetailBean*)p->ptr);
		break;
	case SOAP_TYPE_ns1__TaskExceptionReport:
		if (p->size < 0)
			SOAP_DELETE((ns1__TaskExceptionReport*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__TaskExceptionReport*)p->ptr);
		break;
	case SOAP_TYPE_ns1__SQLException:
		if (p->size < 0)
			SOAP_DELETE((ns1__SQLException*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__SQLException*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTaskProcessReport:
		if (p->size < 0)
			SOAP_DELETE((ns1__getTaskProcessReport*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getTaskProcessReport*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getTaskProcessReportResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getTaskProcessReportResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getTaskProcessReportResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__sendTaskProcess:
		if (p->size < 0)
			SOAP_DELETE((ns1__sendTaskProcess*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__sendTaskProcess*)p->ptr);
		break;
	case SOAP_TYPE_ns1__sendTaskProcessResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__sendTaskProcessResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__sendTaskProcessResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getPackList:
		if (p->size < 0)
			SOAP_DELETE((ns1__getPackList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getPackList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getPackListResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getPackListResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getPackListResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDcp:
		if (p->size < 0)
			SOAP_DELETE((ns1__getDcp*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getDcp*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getDcpResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getDcpResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getDcpResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getExceptionReport:
		if (p->size < 0)
			SOAP_DELETE((ns1__getExceptionReport*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getExceptionReport*)p->ptr);
		break;
	case SOAP_TYPE_ns1__getExceptionReportResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__getExceptionReportResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__getExceptionReportResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__abstractList:
		if (p->size < 0)
			SOAP_DELETE((ns1__abstractList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__abstractList*)p->ptr);
		break;
	case SOAP_TYPE_ns1__arrayList:
		if (p->size < 0)
			SOAP_DELETE((ns1__arrayList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__arrayList*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
	case SOAP_TYPE___ns1__getTaskProcessReport:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getTaskProcessReport*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getTaskProcessReport*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getPackList:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getPackList*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getPackList*)p->ptr);
		break;
	case SOAP_TYPE___ns1__sendTaskProcess:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__sendTaskProcess*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__sendTaskProcess*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getDcp:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getDcp*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getDcp*)p->ptr);
		break;
	case SOAP_TYPE___ns1__getExceptionReport:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__getExceptionReport*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__getExceptionReport*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__dcpDetailBean:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__dcpDetailBean * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__dcpDetailBean * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaskInfo:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__TaskInfo * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__TaskInfo * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaskProgress:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__TaskProgress * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__TaskProgress * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__dcpDetailBean:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__dcpDetailBean * >*)p)[len] = *(ns1__dcpDetailBean **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaskInfo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__TaskInfo * >*)p)[len] = *(ns1__TaskInfo **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaskProgress:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container soap_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__TaskProgress * >*)p)[len] = *(ns1__TaskProgress **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{	float *p;
	p = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag?tag:"float", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::string, n);
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void ns1__getExceptionReportResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getExceptionReportResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getExceptionReportResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getExceptionReportResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__getExceptionReportResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getExceptionReportResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getExceptionReportResponse(struct soap *soap, const char *tag, int id, const ns1__getExceptionReportResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getExceptionReportResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns1__getExceptionReportResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getExceptionReportResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getExceptionReportResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getExceptionReportResponse * SOAP_FMAC4 soap_in_ns1__getExceptionReportResponse(struct soap *soap, const char *tag, ns1__getExceptionReportResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getExceptionReportResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getExceptionReportResponse, sizeof(ns1__getExceptionReportResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getExceptionReportResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getExceptionReportResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns1__getExceptionReportResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getExceptionReportResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getExceptionReportResponse, 0, sizeof(ns1__getExceptionReportResponse), 0, soap_copy_ns1__getExceptionReportResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getExceptionReportResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getExceptionReportResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getExceptionReportResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getExceptionReportResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getExceptionReportResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getExceptionReportResponse * SOAP_FMAC4 soap_get_ns1__getExceptionReportResponse(struct soap *soap, ns1__getExceptionReportResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getExceptionReportResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getExceptionReportResponse * SOAP_FMAC2 soap_instantiate_ns1__getExceptionReportResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getExceptionReportResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getExceptionReportResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getExceptionReportResponse);
		if (size)
			*size = sizeof(ns1__getExceptionReportResponse);
		((ns1__getExceptionReportResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getExceptionReportResponse, n);
		if (size)
			*size = n * sizeof(ns1__getExceptionReportResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getExceptionReportResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getExceptionReportResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getExceptionReportResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getExceptionReportResponse %p -> %p\n", q, p));
	*(ns1__getExceptionReportResponse*)p = *(ns1__getExceptionReportResponse*)q;
}

void ns1__getExceptionReport::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getExceptionReport::arg0 = NULL;
	/* transient soap skipped */
}

void ns1__getExceptionReport::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TaskExceptionReport(soap, &this->ns1__getExceptionReport::arg0);
	/* transient soap skipped */
#endif
}

int ns1__getExceptionReport::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getExceptionReport(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getExceptionReport(struct soap *soap, const char *tag, int id, const ns1__getExceptionReport *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getExceptionReport), type))
		return soap->error;
	if (soap_out_PointerTons1__TaskExceptionReport(soap, "arg0", -1, &(a->ns1__getExceptionReport::arg0), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getExceptionReport::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getExceptionReport(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getExceptionReport * SOAP_FMAC4 soap_in_ns1__getExceptionReport(struct soap *soap, const char *tag, ns1__getExceptionReport *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getExceptionReport *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getExceptionReport, sizeof(ns1__getExceptionReport), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getExceptionReport)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getExceptionReport *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TaskExceptionReport(soap, "arg0", &(a->ns1__getExceptionReport::arg0), "ns1:TaskExceptionReport"))
				{	soap_flag_arg01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getExceptionReport *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getExceptionReport, 0, sizeof(ns1__getExceptionReport), 0, soap_copy_ns1__getExceptionReport);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getExceptionReport::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getExceptionReport);
	if (this->soap_out(soap, tag?tag:"ns1:getExceptionReport", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getExceptionReport::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getExceptionReport(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getExceptionReport * SOAP_FMAC4 soap_get_ns1__getExceptionReport(struct soap *soap, ns1__getExceptionReport *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getExceptionReport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getExceptionReport * SOAP_FMAC2 soap_instantiate_ns1__getExceptionReport(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getExceptionReport(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getExceptionReport, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getExceptionReport);
		if (size)
			*size = sizeof(ns1__getExceptionReport);
		((ns1__getExceptionReport*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getExceptionReport, n);
		if (size)
			*size = n * sizeof(ns1__getExceptionReport);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getExceptionReport*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getExceptionReport*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getExceptionReport(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getExceptionReport %p -> %p\n", q, p));
	*(ns1__getExceptionReport*)p = *(ns1__getExceptionReport*)q;
}

void ns1__getDcpResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getDcpResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getDcpResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__dcpBean(soap, &this->ns1__getDcpResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__getDcpResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getDcpResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDcpResponse(struct soap *soap, const char *tag, int id, const ns1__getDcpResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDcpResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__dcpBean(soap, "return", -1, &(a->ns1__getDcpResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getDcpResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getDcpResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getDcpResponse * SOAP_FMAC4 soap_in_ns1__getDcpResponse(struct soap *soap, const char *tag, ns1__getDcpResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getDcpResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDcpResponse, sizeof(ns1__getDcpResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getDcpResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getDcpResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__dcpBean(soap, "return", &(a->ns1__getDcpResponse::return_), "ns1:dcpBean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getDcpResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDcpResponse, 0, sizeof(ns1__getDcpResponse), 0, soap_copy_ns1__getDcpResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getDcpResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getDcpResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getDcpResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getDcpResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getDcpResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getDcpResponse * SOAP_FMAC4 soap_get_ns1__getDcpResponse(struct soap *soap, ns1__getDcpResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDcpResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getDcpResponse * SOAP_FMAC2 soap_instantiate_ns1__getDcpResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDcpResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDcpResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDcpResponse);
		if (size)
			*size = sizeof(ns1__getDcpResponse);
		((ns1__getDcpResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getDcpResponse, n);
		if (size)
			*size = n * sizeof(ns1__getDcpResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getDcpResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getDcpResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDcpResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getDcpResponse %p -> %p\n", q, p));
	*(ns1__getDcpResponse*)p = *(ns1__getDcpResponse*)q;
}

void ns1__getDcp::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__getDcp::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns1__getDcp::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getDcp(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDcp(struct soap *soap, const char *tag, int id, const ns1__getDcp *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDcp), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getDcp::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getDcp(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getDcp * SOAP_FMAC4 soap_in_ns1__getDcp(struct soap *soap, const char *tag, ns1__getDcp *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getDcp *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDcp, sizeof(ns1__getDcp), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getDcp)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getDcp *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getDcp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDcp, 0, sizeof(ns1__getDcp), 0, soap_copy_ns1__getDcp);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getDcp::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getDcp);
	if (this->soap_out(soap, tag?tag:"ns1:getDcp", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getDcp::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getDcp(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getDcp * SOAP_FMAC4 soap_get_ns1__getDcp(struct soap *soap, ns1__getDcp *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDcp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getDcp * SOAP_FMAC2 soap_instantiate_ns1__getDcp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDcp(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDcp, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getDcp);
		if (size)
			*size = sizeof(ns1__getDcp);
		((ns1__getDcp*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getDcp, n);
		if (size)
			*size = n * sizeof(ns1__getDcp);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getDcp*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getDcp*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDcp(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getDcp %p -> %p\n", q, p));
	*(ns1__getDcp*)p = *(ns1__getDcp*)q;
}

void ns1__getPackListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getPackListResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getPackListResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getPackListResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__getPackListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getPackListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPackListResponse(struct soap *soap, const char *tag, int id, const ns1__getPackListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPackListResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns1__getPackListResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getPackListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getPackListResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getPackListResponse * SOAP_FMAC4 soap_in_ns1__getPackListResponse(struct soap *soap, const char *tag, ns1__getPackListResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getPackListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPackListResponse, sizeof(ns1__getPackListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getPackListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getPackListResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns1__getPackListResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getPackListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPackListResponse, 0, sizeof(ns1__getPackListResponse), 0, soap_copy_ns1__getPackListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getPackListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getPackListResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getPackListResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getPackListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getPackListResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getPackListResponse * SOAP_FMAC4 soap_get_ns1__getPackListResponse(struct soap *soap, ns1__getPackListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPackListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getPackListResponse * SOAP_FMAC2 soap_instantiate_ns1__getPackListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPackListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getPackListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getPackListResponse);
		if (size)
			*size = sizeof(ns1__getPackListResponse);
		((ns1__getPackListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getPackListResponse, n);
		if (size)
			*size = n * sizeof(ns1__getPackListResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getPackListResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getPackListResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getPackListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getPackListResponse %p -> %p\n", q, p));
	*(ns1__getPackListResponse*)p = *(ns1__getPackListResponse*)q;
}

void ns1__getPackList::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__getPackList::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns1__getPackList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getPackList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPackList(struct soap *soap, const char *tag, int id, const ns1__getPackList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPackList), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getPackList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getPackList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getPackList * SOAP_FMAC4 soap_in_ns1__getPackList(struct soap *soap, const char *tag, ns1__getPackList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getPackList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPackList, sizeof(ns1__getPackList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getPackList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getPackList *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getPackList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPackList, 0, sizeof(ns1__getPackList), 0, soap_copy_ns1__getPackList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getPackList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getPackList);
	if (this->soap_out(soap, tag?tag:"ns1:getPackList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getPackList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getPackList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getPackList * SOAP_FMAC4 soap_get_ns1__getPackList(struct soap *soap, ns1__getPackList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPackList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getPackList * SOAP_FMAC2 soap_instantiate_ns1__getPackList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPackList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getPackList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getPackList);
		if (size)
			*size = sizeof(ns1__getPackList);
		((ns1__getPackList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getPackList, n);
		if (size)
			*size = n * sizeof(ns1__getPackList);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getPackList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getPackList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getPackList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getPackList %p -> %p\n", q, p));
	*(ns1__getPackList*)p = *(ns1__getPackList*)q;
}

void ns1__sendTaskProcessResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__sendTaskProcessResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__sendTaskProcessResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TaskOper(soap, &this->ns1__sendTaskProcessResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__sendTaskProcessResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__sendTaskProcessResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sendTaskProcessResponse(struct soap *soap, const char *tag, int id, const ns1__sendTaskProcessResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sendTaskProcessResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__TaskOper(soap, "return", -1, &(a->ns1__sendTaskProcessResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__sendTaskProcessResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__sendTaskProcessResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__sendTaskProcessResponse * SOAP_FMAC4 soap_in_ns1__sendTaskProcessResponse(struct soap *soap, const char *tag, ns1__sendTaskProcessResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__sendTaskProcessResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sendTaskProcessResponse, sizeof(ns1__sendTaskProcessResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__sendTaskProcessResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__sendTaskProcessResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TaskOper(soap, "return", &(a->ns1__sendTaskProcessResponse::return_), "ns1:TaskOper"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__sendTaskProcessResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sendTaskProcessResponse, 0, sizeof(ns1__sendTaskProcessResponse), 0, soap_copy_ns1__sendTaskProcessResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__sendTaskProcessResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__sendTaskProcessResponse);
	if (this->soap_out(soap, tag?tag:"ns1:sendTaskProcessResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__sendTaskProcessResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__sendTaskProcessResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__sendTaskProcessResponse * SOAP_FMAC4 soap_get_ns1__sendTaskProcessResponse(struct soap *soap, ns1__sendTaskProcessResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sendTaskProcessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__sendTaskProcessResponse * SOAP_FMAC2 soap_instantiate_ns1__sendTaskProcessResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__sendTaskProcessResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__sendTaskProcessResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__sendTaskProcessResponse);
		if (size)
			*size = sizeof(ns1__sendTaskProcessResponse);
		((ns1__sendTaskProcessResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__sendTaskProcessResponse, n);
		if (size)
			*size = n * sizeof(ns1__sendTaskProcessResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__sendTaskProcessResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__sendTaskProcessResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__sendTaskProcessResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__sendTaskProcessResponse %p -> %p\n", q, p));
	*(ns1__sendTaskProcessResponse*)p = *(ns1__sendTaskProcessResponse*)q;
}

void ns1__sendTaskProcess::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__sendTaskProcess::arg0 = NULL;
	/* transient soap skipped */
}

void ns1__sendTaskProcess::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TaskOper(soap, &this->ns1__sendTaskProcess::arg0);
	/* transient soap skipped */
#endif
}

int ns1__sendTaskProcess::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__sendTaskProcess(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sendTaskProcess(struct soap *soap, const char *tag, int id, const ns1__sendTaskProcess *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sendTaskProcess), type))
		return soap->error;
	if (soap_out_PointerTons1__TaskOper(soap, "arg0", -1, &(a->ns1__sendTaskProcess::arg0), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__sendTaskProcess::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__sendTaskProcess(soap, tag, this, type);
}

SOAP_FMAC3 ns1__sendTaskProcess * SOAP_FMAC4 soap_in_ns1__sendTaskProcess(struct soap *soap, const char *tag, ns1__sendTaskProcess *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__sendTaskProcess *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sendTaskProcess, sizeof(ns1__sendTaskProcess), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__sendTaskProcess)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__sendTaskProcess *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TaskOper(soap, "arg0", &(a->ns1__sendTaskProcess::arg0), "ns1:TaskOper"))
				{	soap_flag_arg01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__sendTaskProcess *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sendTaskProcess, 0, sizeof(ns1__sendTaskProcess), 0, soap_copy_ns1__sendTaskProcess);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__sendTaskProcess::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__sendTaskProcess);
	if (this->soap_out(soap, tag?tag:"ns1:sendTaskProcess", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__sendTaskProcess::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__sendTaskProcess(soap, this, tag, type);
}

SOAP_FMAC3 ns1__sendTaskProcess * SOAP_FMAC4 soap_get_ns1__sendTaskProcess(struct soap *soap, ns1__sendTaskProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sendTaskProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__sendTaskProcess * SOAP_FMAC2 soap_instantiate_ns1__sendTaskProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__sendTaskProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__sendTaskProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__sendTaskProcess);
		if (size)
			*size = sizeof(ns1__sendTaskProcess);
		((ns1__sendTaskProcess*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__sendTaskProcess, n);
		if (size)
			*size = n * sizeof(ns1__sendTaskProcess);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__sendTaskProcess*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__sendTaskProcess*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__sendTaskProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__sendTaskProcess %p -> %p\n", q, p));
	*(ns1__sendTaskProcess*)p = *(ns1__sendTaskProcess*)q;
}

void ns1__getTaskProcessReportResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getTaskProcessReportResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getTaskProcessReportResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getTaskProcessReportResponse::return_);
	/* transient soap skipped */
#endif
}

int ns1__getTaskProcessReportResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getTaskProcessReportResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTaskProcessReportResponse(struct soap *soap, const char *tag, int id, const ns1__getTaskProcessReportResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTaskProcessReportResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns1__getTaskProcessReportResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getTaskProcessReportResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getTaskProcessReportResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getTaskProcessReportResponse * SOAP_FMAC4 soap_in_ns1__getTaskProcessReportResponse(struct soap *soap, const char *tag, ns1__getTaskProcessReportResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getTaskProcessReportResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTaskProcessReportResponse, sizeof(ns1__getTaskProcessReportResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getTaskProcessReportResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getTaskProcessReportResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns1__getTaskProcessReportResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getTaskProcessReportResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTaskProcessReportResponse, 0, sizeof(ns1__getTaskProcessReportResponse), 0, soap_copy_ns1__getTaskProcessReportResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getTaskProcessReportResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getTaskProcessReportResponse);
	if (this->soap_out(soap, tag?tag:"ns1:getTaskProcessReportResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getTaskProcessReportResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getTaskProcessReportResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getTaskProcessReportResponse * SOAP_FMAC4 soap_get_ns1__getTaskProcessReportResponse(struct soap *soap, ns1__getTaskProcessReportResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTaskProcessReportResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getTaskProcessReportResponse * SOAP_FMAC2 soap_instantiate_ns1__getTaskProcessReportResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTaskProcessReportResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTaskProcessReportResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getTaskProcessReportResponse);
		if (size)
			*size = sizeof(ns1__getTaskProcessReportResponse);
		((ns1__getTaskProcessReportResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getTaskProcessReportResponse, n);
		if (size)
			*size = n * sizeof(ns1__getTaskProcessReportResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getTaskProcessReportResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getTaskProcessReportResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTaskProcessReportResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getTaskProcessReportResponse %p -> %p\n", q, p));
	*(ns1__getTaskProcessReportResponse*)p = *(ns1__getTaskProcessReportResponse*)q;
}

void ns1__getTaskProcessReport::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getTaskProcessReport::arg0 = NULL;
	/* transient soap skipped */
}

void ns1__getTaskProcessReport::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TaskProcessReport(soap, &this->ns1__getTaskProcessReport::arg0);
	/* transient soap skipped */
#endif
}

int ns1__getTaskProcessReport::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getTaskProcessReport(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getTaskProcessReport(struct soap *soap, const char *tag, int id, const ns1__getTaskProcessReport *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getTaskProcessReport), type))
		return soap->error;
	if (soap_out_PointerTons1__TaskProcessReport(soap, "arg0", -1, &(a->ns1__getTaskProcessReport::arg0), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getTaskProcessReport::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getTaskProcessReport(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getTaskProcessReport * SOAP_FMAC4 soap_in_ns1__getTaskProcessReport(struct soap *soap, const char *tag, ns1__getTaskProcessReport *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getTaskProcessReport *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getTaskProcessReport, sizeof(ns1__getTaskProcessReport), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getTaskProcessReport)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getTaskProcessReport *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_arg01 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg01 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TaskProcessReport(soap, "arg0", &(a->ns1__getTaskProcessReport::arg0), "ns1:TaskProcessReport"))
				{	soap_flag_arg01--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getTaskProcessReport *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getTaskProcessReport, 0, sizeof(ns1__getTaskProcessReport), 0, soap_copy_ns1__getTaskProcessReport);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__getTaskProcessReport::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getTaskProcessReport);
	if (this->soap_out(soap, tag?tag:"ns1:getTaskProcessReport", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__getTaskProcessReport::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getTaskProcessReport(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getTaskProcessReport * SOAP_FMAC4 soap_get_ns1__getTaskProcessReport(struct soap *soap, ns1__getTaskProcessReport *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getTaskProcessReport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__getTaskProcessReport * SOAP_FMAC2 soap_instantiate_ns1__getTaskProcessReport(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getTaskProcessReport(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getTaskProcessReport, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__getTaskProcessReport);
		if (size)
			*size = sizeof(ns1__getTaskProcessReport);
		((ns1__getTaskProcessReport*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__getTaskProcessReport, n);
		if (size)
			*size = n * sizeof(ns1__getTaskProcessReport);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__getTaskProcessReport*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__getTaskProcessReport*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getTaskProcessReport(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getTaskProcessReport %p -> %p\n", q, p));
	*(ns1__getTaskProcessReport*)p = *(ns1__getTaskProcessReport*)q;
}

void ns1__SQLException::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__SQLException::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns1__SQLException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SQLException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SQLException(struct soap *soap, const char *tag, int id, const ns1__SQLException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SQLException), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__SQLException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SQLException(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SQLException * SOAP_FMAC4 soap_in_ns1__SQLException(struct soap *soap, const char *tag, ns1__SQLException *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SQLException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SQLException, sizeof(ns1__SQLException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SQLException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SQLException *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SQLException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SQLException, 0, sizeof(ns1__SQLException), 0, soap_copy_ns1__SQLException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__SQLException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SQLException);
	if (this->soap_out(soap, tag?tag:"ns1:SQLException", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__SQLException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SQLException(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SQLException * SOAP_FMAC4 soap_get_ns1__SQLException(struct soap *soap, ns1__SQLException *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SQLException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__SQLException * SOAP_FMAC2 soap_instantiate_ns1__SQLException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SQLException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SQLException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__SQLException);
		if (size)
			*size = sizeof(ns1__SQLException);
		((ns1__SQLException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__SQLException, n);
		if (size)
			*size = n * sizeof(ns1__SQLException);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__SQLException*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__SQLException*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SQLException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SQLException %p -> %p\n", q, p));
	*(ns1__SQLException*)p = *(ns1__SQLException*)q;
}

void ns1__TaskExceptionReport::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__TaskExceptionReport::peerID = NULL;
	this->ns1__TaskExceptionReport::taskInfo = NULL;
	soap_default_std__string(soap, &this->ns1__TaskExceptionReport::errID);
	/* transient soap skipped */
}

void ns1__TaskExceptionReport::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__TaskExceptionReport::peerID);
	soap_serialize_PointerTons1__TaskInfo(soap, &this->ns1__TaskExceptionReport::taskInfo);
	soap_embedded(soap, &this->ns1__TaskExceptionReport::errID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__TaskExceptionReport::errID);
	/* transient soap skipped */
#endif
}

int ns1__TaskExceptionReport::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TaskExceptionReport(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TaskExceptionReport(struct soap *soap, const char *tag, int id, const ns1__TaskExceptionReport *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TaskExceptionReport), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "peerID", -1, &(a->ns1__TaskExceptionReport::peerID), ""))
		return soap->error;
	if (soap_out_PointerTons1__TaskInfo(soap, "taskInfo", -1, &(a->ns1__TaskExceptionReport::taskInfo), ""))
		return soap->error;
	if (soap_out_std__string(soap, "errID", -1, &(a->ns1__TaskExceptionReport::errID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__TaskExceptionReport::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__TaskExceptionReport(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TaskExceptionReport * SOAP_FMAC4 soap_in_ns1__TaskExceptionReport(struct soap *soap, const char *tag, ns1__TaskExceptionReport *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TaskExceptionReport *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TaskExceptionReport, sizeof(ns1__TaskExceptionReport), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__TaskExceptionReport)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__TaskExceptionReport *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_peerID1 = 1;
	size_t soap_flag_taskInfo1 = 1;
	size_t soap_flag_errID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_peerID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "peerID", &(a->ns1__TaskExceptionReport::peerID), "xsd:string"))
				{	soap_flag_peerID1--;
					continue;
				}
			if (soap_flag_taskInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TaskInfo(soap, "taskInfo", &(a->ns1__TaskExceptionReport::taskInfo), "ns1:TaskInfo"))
				{	soap_flag_taskInfo1--;
					continue;
				}
			if (soap_flag_errID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "errID", &(a->ns1__TaskExceptionReport::errID), "xsd:string"))
				{	soap_flag_errID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TaskExceptionReport *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TaskExceptionReport, 0, sizeof(ns1__TaskExceptionReport), 0, soap_copy_ns1__TaskExceptionReport);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_errID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__TaskExceptionReport::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__TaskExceptionReport);
	if (this->soap_out(soap, tag?tag:"ns1:TaskExceptionReport", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TaskExceptionReport::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TaskExceptionReport(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TaskExceptionReport * SOAP_FMAC4 soap_get_ns1__TaskExceptionReport(struct soap *soap, ns1__TaskExceptionReport *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TaskExceptionReport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__TaskExceptionReport * SOAP_FMAC2 soap_instantiate_ns1__TaskExceptionReport(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TaskExceptionReport(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__TaskExceptionReport, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__TaskExceptionReport);
		if (size)
			*size = sizeof(ns1__TaskExceptionReport);
		((ns1__TaskExceptionReport*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__TaskExceptionReport, n);
		if (size)
			*size = n * sizeof(ns1__TaskExceptionReport);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__TaskExceptionReport*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__TaskExceptionReport*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__TaskExceptionReport(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__TaskExceptionReport %p -> %p\n", q, p));
	*(ns1__TaskExceptionReport*)p = *(ns1__TaskExceptionReport*)q;
}

void ns1__dcpDetailBean::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__dcpDetailBean::dcpTitle = NULL;
	this->ns1__dcpDetailBean::ftpDownloadURL = NULL;
	this->ns1__dcpDetailBean::uuid = NULL;
	/* transient soap skipped */
}

void ns1__dcpDetailBean::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__dcpDetailBean::dcpTitle);
	soap_serialize_PointerTostd__string(soap, &this->ns1__dcpDetailBean::ftpDownloadURL);
	soap_serialize_PointerTostd__string(soap, &this->ns1__dcpDetailBean::uuid);
	/* transient soap skipped */
#endif
}

int ns1__dcpDetailBean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__dcpDetailBean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__dcpDetailBean(struct soap *soap, const char *tag, int id, const ns1__dcpDetailBean *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__dcpDetailBean), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "dcpTitle", -1, &(a->ns1__dcpDetailBean::dcpTitle), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ftpDownloadURL", -1, &(a->ns1__dcpDetailBean::ftpDownloadURL), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "uuid", -1, &(a->ns1__dcpDetailBean::uuid), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__dcpDetailBean::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__dcpDetailBean(soap, tag, this, type);
}

SOAP_FMAC3 ns1__dcpDetailBean * SOAP_FMAC4 soap_in_ns1__dcpDetailBean(struct soap *soap, const char *tag, ns1__dcpDetailBean *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__dcpDetailBean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__dcpDetailBean, sizeof(ns1__dcpDetailBean), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__dcpDetailBean)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__dcpDetailBean *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_dcpTitle1 = 1;
	size_t soap_flag_ftpDownloadURL1 = 1;
	size_t soap_flag_uuid1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dcpTitle1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "dcpTitle", &(a->ns1__dcpDetailBean::dcpTitle), "xsd:string"))
				{	soap_flag_dcpTitle1--;
					continue;
				}
			if (soap_flag_ftpDownloadURL1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ftpDownloadURL", &(a->ns1__dcpDetailBean::ftpDownloadURL), "xsd:string"))
				{	soap_flag_ftpDownloadURL1--;
					continue;
				}
			if (soap_flag_uuid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "uuid", &(a->ns1__dcpDetailBean::uuid), "xsd:string"))
				{	soap_flag_uuid1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__dcpDetailBean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__dcpDetailBean, 0, sizeof(ns1__dcpDetailBean), 0, soap_copy_ns1__dcpDetailBean);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__dcpDetailBean::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__dcpDetailBean);
	if (this->soap_out(soap, tag?tag:"ns1:dcpDetailBean", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__dcpDetailBean::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__dcpDetailBean(soap, this, tag, type);
}

SOAP_FMAC3 ns1__dcpDetailBean * SOAP_FMAC4 soap_get_ns1__dcpDetailBean(struct soap *soap, ns1__dcpDetailBean *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__dcpDetailBean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__dcpDetailBean * SOAP_FMAC2 soap_instantiate_ns1__dcpDetailBean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__dcpDetailBean(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__dcpDetailBean, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__dcpDetailBean);
		if (size)
			*size = sizeof(ns1__dcpDetailBean);
		((ns1__dcpDetailBean*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__dcpDetailBean, n);
		if (size)
			*size = n * sizeof(ns1__dcpDetailBean);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__dcpDetailBean*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__dcpDetailBean*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__dcpDetailBean(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__dcpDetailBean %p -> %p\n", q, p));
	*(ns1__dcpDetailBean*)p = *(ns1__dcpDetailBean*)q;
}

void ns1__dcpBean::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__dcpDetailBean(soap, &this->ns1__dcpBean::record);
	soap_default_int(soap, &this->ns1__dcpBean::resultCode);
	/* transient soap skipped */
}

void ns1__dcpBean::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__dcpDetailBean(soap, &this->ns1__dcpBean::record);
	/* transient soap skipped */
#endif
}

int ns1__dcpBean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__dcpBean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__dcpBean(struct soap *soap, const char *tag, int id, const ns1__dcpBean *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__dcpBean), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__dcpDetailBean(soap, "record", -1, &(a->ns1__dcpBean::record), ""))
		return soap->error;
	if (soap_out_int(soap, "resultCode", -1, &(a->ns1__dcpBean::resultCode), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__dcpBean::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__dcpBean(soap, tag, this, type);
}

SOAP_FMAC3 ns1__dcpBean * SOAP_FMAC4 soap_in_ns1__dcpBean(struct soap *soap, const char *tag, ns1__dcpBean *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__dcpBean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__dcpBean, sizeof(ns1__dcpBean), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__dcpBean)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__dcpBean *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_resultCode1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__dcpDetailBean(soap, "record", &(a->ns1__dcpBean::record), "ns1:dcpDetailBean"))
					continue;
			if (soap_flag_resultCode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "resultCode", &(a->ns1__dcpBean::resultCode), "xsd:int"))
				{	soap_flag_resultCode1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__dcpBean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__dcpBean, 0, sizeof(ns1__dcpBean), 0, soap_copy_ns1__dcpBean);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resultCode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__dcpBean::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__dcpBean);
	if (this->soap_out(soap, tag?tag:"ns1:dcpBean", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__dcpBean::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__dcpBean(soap, this, tag, type);
}

SOAP_FMAC3 ns1__dcpBean * SOAP_FMAC4 soap_get_ns1__dcpBean(struct soap *soap, ns1__dcpBean *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__dcpBean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__dcpBean * SOAP_FMAC2 soap_instantiate_ns1__dcpBean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__dcpBean(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__dcpBean, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__dcpBean);
		if (size)
			*size = sizeof(ns1__dcpBean);
		((ns1__dcpBean*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__dcpBean, n);
		if (size)
			*size = n * sizeof(ns1__dcpBean);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__dcpBean*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__dcpBean*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__dcpBean(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__dcpBean %p -> %p\n", q, p));
	*(ns1__dcpBean*)p = *(ns1__dcpBean*)q;
}

void ns1__TaskOper::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__TaskOper::peerID = NULL;
	this->ns1__TaskOper::operType = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__TaskInfo(soap, &this->ns1__TaskOper::taskInfoList);
	/* transient soap skipped */
}

void ns1__TaskOper::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__TaskOper::peerID);
	soap_serialize_PointerTostd__string(soap, &this->ns1__TaskOper::operType);
	soap_serialize_std__vectorTemplateOfPointerTons1__TaskInfo(soap, &this->ns1__TaskOper::taskInfoList);
	/* transient soap skipped */
#endif
}

int ns1__TaskOper::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TaskOper(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TaskOper(struct soap *soap, const char *tag, int id, const ns1__TaskOper *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TaskOper), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "peerID", -1, &(a->ns1__TaskOper::peerID), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "operType", -1, &(a->ns1__TaskOper::operType), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__TaskInfo(soap, "taskInfoList", -1, &(a->ns1__TaskOper::taskInfoList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__TaskOper::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__TaskOper(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TaskOper * SOAP_FMAC4 soap_in_ns1__TaskOper(struct soap *soap, const char *tag, ns1__TaskOper *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TaskOper *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TaskOper, sizeof(ns1__TaskOper), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__TaskOper)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__TaskOper *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_peerID1 = 1;
	size_t soap_flag_operType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_peerID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "peerID", &(a->ns1__TaskOper::peerID), "xsd:string"))
				{	soap_flag_peerID1--;
					continue;
				}
			if (soap_flag_operType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "operType", &(a->ns1__TaskOper::operType), "xsd:string"))
				{	soap_flag_operType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__TaskInfo(soap, "taskInfoList", &(a->ns1__TaskOper::taskInfoList), "ns1:TaskInfo"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TaskOper *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TaskOper, 0, sizeof(ns1__TaskOper), 0, soap_copy_ns1__TaskOper);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__TaskOper::taskInfoList.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__TaskOper::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__TaskOper);
	if (this->soap_out(soap, tag?tag:"ns1:TaskOper", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TaskOper::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TaskOper(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TaskOper * SOAP_FMAC4 soap_get_ns1__TaskOper(struct soap *soap, ns1__TaskOper *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TaskOper(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__TaskOper * SOAP_FMAC2 soap_instantiate_ns1__TaskOper(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TaskOper(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__TaskOper, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__TaskOper);
		if (size)
			*size = sizeof(ns1__TaskOper);
		((ns1__TaskOper*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__TaskOper, n);
		if (size)
			*size = n * sizeof(ns1__TaskOper);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__TaskOper*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__TaskOper*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__TaskOper(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__TaskOper %p -> %p\n", q, p));
	*(ns1__TaskOper*)p = *(ns1__TaskOper*)q;
}

void ns1__arrayList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__abstractList::soap_default(soap);
	this->ns1__abstractCollection::soap_default(soap);
}

void ns1__arrayList::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns1__abstractList::soap_serialize(soap);
	this->ns1__abstractCollection::soap_serialize(soap);
#endif
}

int ns1__arrayList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__arrayList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__arrayList(struct soap *soap, const char *tag, int id, const ns1__arrayList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__arrayList), "ns1:arrayList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__arrayList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__arrayList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__arrayList * SOAP_FMAC4 soap_in_ns1__arrayList(struct soap *soap, const char *tag, ns1__arrayList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__arrayList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__arrayList, sizeof(ns1__arrayList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__arrayList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__arrayList *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__arrayList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__arrayList, 0, sizeof(ns1__arrayList), 0, soap_copy_ns1__arrayList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__arrayList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__arrayList);
	if (this->soap_out(soap, tag?tag:"ns1:arrayList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__arrayList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__arrayList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__arrayList * SOAP_FMAC4 soap_get_ns1__arrayList(struct soap *soap, ns1__arrayList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__arrayList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__arrayList * SOAP_FMAC2 soap_instantiate_ns1__arrayList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__arrayList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__arrayList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__arrayList);
		if (size)
			*size = sizeof(ns1__arrayList);
		((ns1__arrayList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__arrayList, n);
		if (size)
			*size = n * sizeof(ns1__arrayList);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__arrayList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__arrayList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__arrayList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__arrayList %p -> %p\n", q, p));
	*(ns1__arrayList*)p = *(ns1__arrayList*)q;
}

void ns1__abstractList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__abstractCollection::soap_default(soap);
}

void ns1__abstractList::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->ns1__abstractCollection::soap_serialize(soap);
#endif
}

int ns1__abstractList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__abstractList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__abstractList(struct soap *soap, const char *tag, int id, const ns1__abstractList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__abstractList), "ns1:abstractList"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__abstractList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__abstractList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__abstractList * SOAP_FMAC4 soap_in_ns1__abstractList(struct soap *soap, const char *tag, ns1__abstractList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__abstractList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__abstractList, sizeof(ns1__abstractList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__abstractList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__abstractList *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__abstractList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__abstractList, 0, sizeof(ns1__abstractList), 0, soap_copy_ns1__abstractList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__abstractList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__abstractList);
	if (this->soap_out(soap, tag?tag:"ns1:abstractList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__abstractList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__abstractList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__abstractList * SOAP_FMAC4 soap_get_ns1__abstractList(struct soap *soap, ns1__abstractList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__abstractList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__abstractList * SOAP_FMAC2 soap_instantiate_ns1__abstractList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__abstractList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__abstractList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:arrayList"))
	{	cp->type = SOAP_TYPE_ns1__arrayList;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__arrayList);
			if (size)
				*size = sizeof(ns1__arrayList);
			((ns1__arrayList*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__arrayList, n);
			if (size)
				*size = n * sizeof(ns1__arrayList);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__arrayList*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__arrayList*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__abstractList);
		if (size)
			*size = sizeof(ns1__abstractList);
		((ns1__abstractList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__abstractList, n);
		if (size)
			*size = n * sizeof(ns1__abstractList);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__abstractList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__abstractList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__abstractList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__abstractList %p -> %p\n", q, p));
	*(ns1__abstractList*)p = *(ns1__abstractList*)q;
}

void ns1__abstractCollection::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__abstractCollection::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns1__abstractCollection::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__abstractCollection(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__abstractCollection(struct soap *soap, const char *tag, int id, const ns1__abstractCollection *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__abstractCollection), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__abstractCollection::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__abstractCollection(soap, tag, this, type);
}

SOAP_FMAC3 ns1__abstractCollection * SOAP_FMAC4 soap_in_ns1__abstractCollection(struct soap *soap, const char *tag, ns1__abstractCollection *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__abstractCollection *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__abstractCollection, sizeof(ns1__abstractCollection), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__abstractCollection)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__abstractCollection *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__abstractCollection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__abstractCollection, 0, sizeof(ns1__abstractCollection), 0, soap_copy_ns1__abstractCollection);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns1__abstractCollection::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__abstractCollection);
	if (this->soap_out(soap, tag?tag:"ns1:abstractCollection", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__abstractCollection::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__abstractCollection(soap, this, tag, type);
}

SOAP_FMAC3 ns1__abstractCollection * SOAP_FMAC4 soap_get_ns1__abstractCollection(struct soap *soap, ns1__abstractCollection *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__abstractCollection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__abstractCollection * SOAP_FMAC2 soap_instantiate_ns1__abstractCollection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__abstractCollection(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__abstractCollection, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:abstractList"))
	{	cp->type = SOAP_TYPE_ns1__abstractList;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__abstractList);
			if (size)
				*size = sizeof(ns1__abstractList);
			((ns1__abstractList*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__abstractList, n);
			if (size)
				*size = n * sizeof(ns1__abstractList);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__abstractList*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__abstractList*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:arrayList"))
	{	cp->type = SOAP_TYPE_ns1__arrayList;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__arrayList);
			if (size)
				*size = sizeof(ns1__arrayList);
			((ns1__arrayList*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__arrayList, n);
			if (size)
				*size = n * sizeof(ns1__arrayList);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((ns1__arrayList*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (ns1__arrayList*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__abstractCollection);
		if (size)
			*size = sizeof(ns1__abstractCollection);
		((ns1__abstractCollection*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__abstractCollection, n);
		if (size)
			*size = n * sizeof(ns1__abstractCollection);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__abstractCollection*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__abstractCollection*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__abstractCollection(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__abstractCollection %p -> %p\n", q, p));
	*(ns1__abstractCollection*)p = *(ns1__abstractCollection*)q;
}

void ns1__TaskInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__TaskInfo::packageName);
	soap_default_std__string(soap, &this->ns1__TaskInfo::torrentUrl);
	soap_default_std__string(soap, &this->ns1__TaskInfo::filedownloadPath);
	this->ns1__TaskInfo::ftpAdress = NULL;
	this->ns1__TaskInfo::baseStorageFtp = NULL;
	soap_default_int(soap, &this->ns1__TaskInfo::State);
	/* transient soap skipped */
}

void ns1__TaskInfo::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__TaskInfo::packageName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__TaskInfo::packageName);
	soap_embedded(soap, &this->ns1__TaskInfo::torrentUrl, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__TaskInfo::torrentUrl);
	soap_embedded(soap, &this->ns1__TaskInfo::filedownloadPath, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__TaskInfo::filedownloadPath);
	soap_serialize_PointerTostd__string(soap, &this->ns1__TaskInfo::ftpAdress);
	soap_serialize_PointerTostd__string(soap, &this->ns1__TaskInfo::baseStorageFtp);
	/* transient soap skipped */
#endif
}

int ns1__TaskInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TaskInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TaskInfo(struct soap *soap, const char *tag, int id, const ns1__TaskInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TaskInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "packageName", -1, &(a->ns1__TaskInfo::packageName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "torrentUrl", -1, &(a->ns1__TaskInfo::torrentUrl), ""))
		return soap->error;
	if (soap_out_std__string(soap, "filedownloadPath", -1, &(a->ns1__TaskInfo::filedownloadPath), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ftpAdress", -1, &(a->ns1__TaskInfo::ftpAdress), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "baseStorageFtp", -1, &(a->ns1__TaskInfo::baseStorageFtp), ""))
		return soap->error;
	if (soap_out_int(soap, "State", -1, &(a->ns1__TaskInfo::State), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__TaskInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__TaskInfo(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TaskInfo * SOAP_FMAC4 soap_in_ns1__TaskInfo(struct soap *soap, const char *tag, ns1__TaskInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TaskInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TaskInfo, sizeof(ns1__TaskInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__TaskInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__TaskInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_packageName1 = 1;
	size_t soap_flag_torrentUrl1 = 1;
	size_t soap_flag_filedownloadPath1 = 1;
	size_t soap_flag_ftpAdress1 = 1;
	size_t soap_flag_baseStorageFtp1 = 1;
	size_t soap_flag_State1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_packageName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "packageName", &(a->ns1__TaskInfo::packageName), "xsd:string"))
				{	soap_flag_packageName1--;
					continue;
				}
			if (soap_flag_torrentUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "torrentUrl", &(a->ns1__TaskInfo::torrentUrl), "xsd:string"))
				{	soap_flag_torrentUrl1--;
					continue;
				}
			if (soap_flag_filedownloadPath1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "filedownloadPath", &(a->ns1__TaskInfo::filedownloadPath), "xsd:string"))
				{	soap_flag_filedownloadPath1--;
					continue;
				}
			if (soap_flag_ftpAdress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ftpAdress", &(a->ns1__TaskInfo::ftpAdress), "xsd:string"))
				{	soap_flag_ftpAdress1--;
					continue;
				}
			if (soap_flag_baseStorageFtp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "baseStorageFtp", &(a->ns1__TaskInfo::baseStorageFtp), "xsd:string"))
				{	soap_flag_baseStorageFtp1--;
					continue;
				}
			if (soap_flag_State1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "State", &(a->ns1__TaskInfo::State), "xsd:int"))
				{	soap_flag_State1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TaskInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TaskInfo, 0, sizeof(ns1__TaskInfo), 0, soap_copy_ns1__TaskInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_packageName1 > 0 || soap_flag_torrentUrl1 > 0 || soap_flag_filedownloadPath1 > 0 || soap_flag_State1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__TaskInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__TaskInfo);
	if (this->soap_out(soap, tag?tag:"ns1:TaskInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TaskInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TaskInfo(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TaskInfo * SOAP_FMAC4 soap_get_ns1__TaskInfo(struct soap *soap, ns1__TaskInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TaskInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__TaskInfo * SOAP_FMAC2 soap_instantiate_ns1__TaskInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TaskInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__TaskInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__TaskInfo);
		if (size)
			*size = sizeof(ns1__TaskInfo);
		((ns1__TaskInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__TaskInfo, n);
		if (size)
			*size = n * sizeof(ns1__TaskInfo);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__TaskInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__TaskInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__TaskInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__TaskInfo %p -> %p\n", q, p));
	*(ns1__TaskInfo*)p = *(ns1__TaskInfo*)q;
}

void ns1__TaskProgress::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__TaskProgress::taskInfo = NULL;
	soap_default_int(soap, &this->ns1__TaskProgress::totalPeerCnt);
	soap_default_int(soap, &this->ns1__TaskProgress::connectingPeerCnt);
	soap_default_int(soap, &this->ns1__TaskProgress::connectedPeerCnt);
	soap_default_int(soap, &this->ns1__TaskProgress::downloadRate);
	soap_default_int(soap, &this->ns1__TaskProgress::uploadRate);
	soap_default_LONG64(soap, &this->ns1__TaskProgress::downloaded);
	soap_default_LONG64(soap, &this->ns1__TaskProgress::uploaded);
	soap_default_float(soap, &this->ns1__TaskProgress::percentCmp);
	/* transient soap skipped */
}

void ns1__TaskProgress::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TaskInfo(soap, &this->ns1__TaskProgress::taskInfo);
	/* transient soap skipped */
#endif
}

int ns1__TaskProgress::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TaskProgress(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TaskProgress(struct soap *soap, const char *tag, int id, const ns1__TaskProgress *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TaskProgress), type))
		return soap->error;
	if (a->ns1__TaskProgress::taskInfo)
	{	if (soap_out_PointerTons1__TaskInfo(soap, "taskInfo", -1, &a->ns1__TaskProgress::taskInfo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "taskInfo"))
		return soap->error;
	if (soap_out_int(soap, "totalPeerCnt", -1, &(a->ns1__TaskProgress::totalPeerCnt), ""))
		return soap->error;
	if (soap_out_int(soap, "connectingPeerCnt", -1, &(a->ns1__TaskProgress::connectingPeerCnt), ""))
		return soap->error;
	if (soap_out_int(soap, "connectedPeerCnt", -1, &(a->ns1__TaskProgress::connectedPeerCnt), ""))
		return soap->error;
	if (soap_out_int(soap, "downloadRate", -1, &(a->ns1__TaskProgress::downloadRate), ""))
		return soap->error;
	if (soap_out_int(soap, "uploadRate", -1, &(a->ns1__TaskProgress::uploadRate), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "downloaded", -1, &(a->ns1__TaskProgress::downloaded), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "uploaded", -1, &(a->ns1__TaskProgress::uploaded), ""))
		return soap->error;
	if (soap_out_float(soap, "percentCmp", -1, &(a->ns1__TaskProgress::percentCmp), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__TaskProgress::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__TaskProgress(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TaskProgress * SOAP_FMAC4 soap_in_ns1__TaskProgress(struct soap *soap, const char *tag, ns1__TaskProgress *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TaskProgress *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TaskProgress, sizeof(ns1__TaskProgress), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__TaskProgress)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__TaskProgress *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_taskInfo1 = 1;
	size_t soap_flag_totalPeerCnt1 = 1;
	size_t soap_flag_connectingPeerCnt1 = 1;
	size_t soap_flag_connectedPeerCnt1 = 1;
	size_t soap_flag_downloadRate1 = 1;
	size_t soap_flag_uploadRate1 = 1;
	size_t soap_flag_downloaded1 = 1;
	size_t soap_flag_uploaded1 = 1;
	size_t soap_flag_percentCmp1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_taskInfo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TaskInfo(soap, "taskInfo", &(a->ns1__TaskProgress::taskInfo), "ns1:TaskInfo"))
				{	soap_flag_taskInfo1--;
					continue;
				}
			if (soap_flag_totalPeerCnt1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "totalPeerCnt", &(a->ns1__TaskProgress::totalPeerCnt), "xsd:int"))
				{	soap_flag_totalPeerCnt1--;
					continue;
				}
			if (soap_flag_connectingPeerCnt1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "connectingPeerCnt", &(a->ns1__TaskProgress::connectingPeerCnt), "xsd:int"))
				{	soap_flag_connectingPeerCnt1--;
					continue;
				}
			if (soap_flag_connectedPeerCnt1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "connectedPeerCnt", &(a->ns1__TaskProgress::connectedPeerCnt), "xsd:int"))
				{	soap_flag_connectedPeerCnt1--;
					continue;
				}
			if (soap_flag_downloadRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "downloadRate", &(a->ns1__TaskProgress::downloadRate), "xsd:int"))
				{	soap_flag_downloadRate1--;
					continue;
				}
			if (soap_flag_uploadRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "uploadRate", &(a->ns1__TaskProgress::uploadRate), "xsd:int"))
				{	soap_flag_uploadRate1--;
					continue;
				}
			if (soap_flag_downloaded1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "downloaded", &(a->ns1__TaskProgress::downloaded), "xsd:long"))
				{	soap_flag_downloaded1--;
					continue;
				}
			if (soap_flag_uploaded1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "uploaded", &(a->ns1__TaskProgress::uploaded), "xsd:long"))
				{	soap_flag_uploaded1--;
					continue;
				}
			if (soap_flag_percentCmp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "percentCmp", &(a->ns1__TaskProgress::percentCmp), "xsd:float"))
				{	soap_flag_percentCmp1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TaskProgress *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TaskProgress, 0, sizeof(ns1__TaskProgress), 0, soap_copy_ns1__TaskProgress);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_taskInfo1 > 0 || soap_flag_totalPeerCnt1 > 0 || soap_flag_connectingPeerCnt1 > 0 || soap_flag_connectedPeerCnt1 > 0 || soap_flag_downloadRate1 > 0 || soap_flag_uploadRate1 > 0 || soap_flag_downloaded1 > 0 || soap_flag_uploaded1 > 0 || soap_flag_percentCmp1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__TaskProgress::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__TaskProgress);
	if (this->soap_out(soap, tag?tag:"ns1:TaskProgress", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TaskProgress::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TaskProgress(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TaskProgress * SOAP_FMAC4 soap_get_ns1__TaskProgress(struct soap *soap, ns1__TaskProgress *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TaskProgress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__TaskProgress * SOAP_FMAC2 soap_instantiate_ns1__TaskProgress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TaskProgress(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__TaskProgress, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__TaskProgress);
		if (size)
			*size = sizeof(ns1__TaskProgress);
		((ns1__TaskProgress*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__TaskProgress, n);
		if (size)
			*size = n * sizeof(ns1__TaskProgress);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__TaskProgress*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__TaskProgress*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__TaskProgress(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__TaskProgress %p -> %p\n", q, p));
	*(ns1__TaskProgress*)p = *(ns1__TaskProgress*)q;
}

void ns1__TaskProcessReport::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__TaskProcessReport::peerID = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__TaskProgress(soap, &this->ns1__TaskProcessReport::taskProgressList);
	/* transient soap skipped */
}

void ns1__TaskProcessReport::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__TaskProcessReport::peerID);
	soap_serialize_std__vectorTemplateOfPointerTons1__TaskProgress(soap, &this->ns1__TaskProcessReport::taskProgressList);
	/* transient soap skipped */
#endif
}

int ns1__TaskProcessReport::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TaskProcessReport(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TaskProcessReport(struct soap *soap, const char *tag, int id, const ns1__TaskProcessReport *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TaskProcessReport), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "peerID", -1, &(a->ns1__TaskProcessReport::peerID), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__TaskProgress(soap, "taskProgressList", -1, &(a->ns1__TaskProcessReport::taskProgressList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__TaskProcessReport::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__TaskProcessReport(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TaskProcessReport * SOAP_FMAC4 soap_in_ns1__TaskProcessReport(struct soap *soap, const char *tag, ns1__TaskProcessReport *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TaskProcessReport *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TaskProcessReport, sizeof(ns1__TaskProcessReport), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__TaskProcessReport)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__TaskProcessReport *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_peerID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_peerID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "peerID", &(a->ns1__TaskProcessReport::peerID), "xsd:string"))
				{	soap_flag_peerID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__TaskProgress(soap, "taskProgressList", &(a->ns1__TaskProcessReport::taskProgressList), "ns1:TaskProgress"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TaskProcessReport *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TaskProcessReport, 0, sizeof(ns1__TaskProcessReport), 0, soap_copy_ns1__TaskProcessReport);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->ns1__TaskProcessReport::taskProgressList.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__TaskProcessReport::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__TaskProcessReport);
	if (this->soap_out(soap, tag?tag:"ns1:TaskProcessReport", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__TaskProcessReport::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TaskProcessReport(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TaskProcessReport * SOAP_FMAC4 soap_get_ns1__TaskProcessReport(struct soap *soap, ns1__TaskProcessReport *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TaskProcessReport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__TaskProcessReport * SOAP_FMAC2 soap_instantiate_ns1__TaskProcessReport(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TaskProcessReport(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__TaskProcessReport, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__TaskProcessReport);
		if (size)
			*size = sizeof(ns1__TaskProcessReport);
		((ns1__TaskProcessReport*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns1__TaskProcessReport, n);
		if (size)
			*size = n * sizeof(ns1__TaskProcessReport);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns1__TaskProcessReport*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns1__TaskProcessReport*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__TaskProcessReport(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__TaskProcessReport %p -> %p\n", q, p));
	*(ns1__TaskProcessReport*)p = *(ns1__TaskProcessReport*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getExceptionReport(struct soap *soap, struct __ns1__getExceptionReport *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getExceptionReport_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getExceptionReport(struct soap *soap, const struct __ns1__getExceptionReport *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getExceptionReport(soap, &a->ns1__getExceptionReport_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getExceptionReport(struct soap *soap, const char *tag, int id, const struct __ns1__getExceptionReport *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getExceptionReport(soap, "ns1:getExceptionReport", -1, &a->ns1__getExceptionReport_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getExceptionReport * SOAP_FMAC4 soap_in___ns1__getExceptionReport(struct soap *soap, const char *tag, struct __ns1__getExceptionReport *a, const char *type)
{
	size_t soap_flag_ns1__getExceptionReport_ = 1;
	short soap_flag;
	a = (struct __ns1__getExceptionReport *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getExceptionReport, sizeof(struct __ns1__getExceptionReport), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getExceptionReport(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getExceptionReport_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getExceptionReport(soap, "ns1:getExceptionReport", &a->ns1__getExceptionReport_, "ns1:getExceptionReport"))
				{	soap_flag_ns1__getExceptionReport_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getExceptionReport(struct soap *soap, const struct __ns1__getExceptionReport *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getExceptionReport(soap, tag?tag:"-ns1:getExceptionReport", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getExceptionReport * SOAP_FMAC4 soap_get___ns1__getExceptionReport(struct soap *soap, struct __ns1__getExceptionReport *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getExceptionReport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getExceptionReport * SOAP_FMAC2 soap_instantiate___ns1__getExceptionReport(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getExceptionReport(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getExceptionReport, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getExceptionReport);
		if (size)
			*size = sizeof(struct __ns1__getExceptionReport);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getExceptionReport, n);
		if (size)
			*size = n * sizeof(struct __ns1__getExceptionReport);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getExceptionReport*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getExceptionReport(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getExceptionReport %p -> %p\n", q, p));
	*(struct __ns1__getExceptionReport*)p = *(struct __ns1__getExceptionReport*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getDcp(struct soap *soap, struct __ns1__getDcp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getDcp_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getDcp(struct soap *soap, const struct __ns1__getDcp *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getDcp(soap, &a->ns1__getDcp_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getDcp(struct soap *soap, const char *tag, int id, const struct __ns1__getDcp *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getDcp(soap, "ns1:getDcp", -1, &a->ns1__getDcp_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDcp * SOAP_FMAC4 soap_in___ns1__getDcp(struct soap *soap, const char *tag, struct __ns1__getDcp *a, const char *type)
{
	size_t soap_flag_ns1__getDcp_ = 1;
	short soap_flag;
	a = (struct __ns1__getDcp *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getDcp, sizeof(struct __ns1__getDcp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getDcp(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getDcp_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getDcp(soap, "ns1:getDcp", &a->ns1__getDcp_, "ns1:getDcp"))
				{	soap_flag_ns1__getDcp_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getDcp(struct soap *soap, const struct __ns1__getDcp *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getDcp(soap, tag?tag:"-ns1:getDcp", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getDcp * SOAP_FMAC4 soap_get___ns1__getDcp(struct soap *soap, struct __ns1__getDcp *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getDcp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getDcp * SOAP_FMAC2 soap_instantiate___ns1__getDcp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getDcp(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getDcp, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getDcp);
		if (size)
			*size = sizeof(struct __ns1__getDcp);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getDcp, n);
		if (size)
			*size = n * sizeof(struct __ns1__getDcp);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getDcp*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getDcp(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getDcp %p -> %p\n", q, p));
	*(struct __ns1__getDcp*)p = *(struct __ns1__getDcp*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__sendTaskProcess(struct soap *soap, struct __ns1__sendTaskProcess *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__sendTaskProcess_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__sendTaskProcess(struct soap *soap, const struct __ns1__sendTaskProcess *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__sendTaskProcess(soap, &a->ns1__sendTaskProcess_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__sendTaskProcess(struct soap *soap, const char *tag, int id, const struct __ns1__sendTaskProcess *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__sendTaskProcess(soap, "ns1:sendTaskProcess", -1, &a->ns1__sendTaskProcess_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendTaskProcess * SOAP_FMAC4 soap_in___ns1__sendTaskProcess(struct soap *soap, const char *tag, struct __ns1__sendTaskProcess *a, const char *type)
{
	size_t soap_flag_ns1__sendTaskProcess_ = 1;
	short soap_flag;
	a = (struct __ns1__sendTaskProcess *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__sendTaskProcess, sizeof(struct __ns1__sendTaskProcess), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__sendTaskProcess(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__sendTaskProcess_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sendTaskProcess(soap, "ns1:sendTaskProcess", &a->ns1__sendTaskProcess_, "ns1:sendTaskProcess"))
				{	soap_flag_ns1__sendTaskProcess_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__sendTaskProcess(struct soap *soap, const struct __ns1__sendTaskProcess *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__sendTaskProcess(soap, tag?tag:"-ns1:sendTaskProcess", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__sendTaskProcess * SOAP_FMAC4 soap_get___ns1__sendTaskProcess(struct soap *soap, struct __ns1__sendTaskProcess *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__sendTaskProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__sendTaskProcess * SOAP_FMAC2 soap_instantiate___ns1__sendTaskProcess(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__sendTaskProcess(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__sendTaskProcess, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__sendTaskProcess);
		if (size)
			*size = sizeof(struct __ns1__sendTaskProcess);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__sendTaskProcess, n);
		if (size)
			*size = n * sizeof(struct __ns1__sendTaskProcess);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__sendTaskProcess*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__sendTaskProcess(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__sendTaskProcess %p -> %p\n", q, p));
	*(struct __ns1__sendTaskProcess*)p = *(struct __ns1__sendTaskProcess*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPackList(struct soap *soap, struct __ns1__getPackList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPackList_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPackList(struct soap *soap, const struct __ns1__getPackList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getPackList(soap, &a->ns1__getPackList_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPackList(struct soap *soap, const char *tag, int id, const struct __ns1__getPackList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getPackList(soap, "ns1:getPackList", -1, &a->ns1__getPackList_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPackList * SOAP_FMAC4 soap_in___ns1__getPackList(struct soap *soap, const char *tag, struct __ns1__getPackList *a, const char *type)
{
	size_t soap_flag_ns1__getPackList_ = 1;
	short soap_flag;
	a = (struct __ns1__getPackList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPackList, sizeof(struct __ns1__getPackList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPackList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPackList_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getPackList(soap, "ns1:getPackList", &a->ns1__getPackList_, "ns1:getPackList"))
				{	soap_flag_ns1__getPackList_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPackList(struct soap *soap, const struct __ns1__getPackList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getPackList(soap, tag?tag:"-ns1:getPackList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPackList * SOAP_FMAC4 soap_get___ns1__getPackList(struct soap *soap, struct __ns1__getPackList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPackList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getPackList * SOAP_FMAC2 soap_instantiate___ns1__getPackList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPackList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getPackList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getPackList);
		if (size)
			*size = sizeof(struct __ns1__getPackList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getPackList, n);
		if (size)
			*size = n * sizeof(struct __ns1__getPackList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getPackList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getPackList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getPackList %p -> %p\n", q, p));
	*(struct __ns1__getPackList*)p = *(struct __ns1__getPackList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getTaskProcessReport(struct soap *soap, struct __ns1__getTaskProcessReport *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getTaskProcessReport_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getTaskProcessReport(struct soap *soap, const struct __ns1__getTaskProcessReport *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getTaskProcessReport(soap, &a->ns1__getTaskProcessReport_);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getTaskProcessReport(struct soap *soap, const char *tag, int id, const struct __ns1__getTaskProcessReport *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__getTaskProcessReport(soap, "ns1:getTaskProcessReport", -1, &a->ns1__getTaskProcessReport_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTaskProcessReport * SOAP_FMAC4 soap_in___ns1__getTaskProcessReport(struct soap *soap, const char *tag, struct __ns1__getTaskProcessReport *a, const char *type)
{
	size_t soap_flag_ns1__getTaskProcessReport_ = 1;
	short soap_flag;
	a = (struct __ns1__getTaskProcessReport *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getTaskProcessReport, sizeof(struct __ns1__getTaskProcessReport), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getTaskProcessReport(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getTaskProcessReport_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getTaskProcessReport(soap, "ns1:getTaskProcessReport", &a->ns1__getTaskProcessReport_, "ns1:getTaskProcessReport"))
				{	soap_flag_ns1__getTaskProcessReport_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getTaskProcessReport(struct soap *soap, const struct __ns1__getTaskProcessReport *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getTaskProcessReport(soap, tag?tag:"-ns1:getTaskProcessReport", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getTaskProcessReport * SOAP_FMAC4 soap_get___ns1__getTaskProcessReport(struct soap *soap, struct __ns1__getTaskProcessReport *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getTaskProcessReport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__getTaskProcessReport * SOAP_FMAC2 soap_instantiate___ns1__getTaskProcessReport(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getTaskProcessReport(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getTaskProcessReport, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__getTaskProcessReport);
		if (size)
			*size = sizeof(struct __ns1__getTaskProcessReport);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __ns1__getTaskProcessReport, n);
		if (size)
			*size = n * sizeof(struct __ns1__getTaskProcessReport);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __ns1__getTaskProcessReport*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getTaskProcessReport(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getTaskProcessReport %p -> %p\n", q, p));
	*(struct __ns1__getTaskProcessReport*)p = *(struct __ns1__getTaskProcessReport*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->ns1__SQLException_ = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__SQLException(soap, &a->ns1__SQLException_);
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_out_PointerTons1__SQLException(soap, "ns1:SQLException", -1, &a->ns1__SQLException_, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_ns1__SQLException_ = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__SQLException_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SQLException(soap, "ns1:SQLException", &a->ns1__SQLException_, "ns1:SQLException"))
				{	soap_flag_ns1__SQLException_--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getExceptionReportResponse(struct soap *soap, ns1__getExceptionReportResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getExceptionReportResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getExceptionReportResponse(struct soap *soap, const char *tag, int id, ns1__getExceptionReportResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getExceptionReportResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getExceptionReportResponse ** SOAP_FMAC4 soap_in_PointerTons1__getExceptionReportResponse(struct soap *soap, const char *tag, ns1__getExceptionReportResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getExceptionReportResponse **)soap_malloc(soap, sizeof(ns1__getExceptionReportResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getExceptionReportResponse *)soap_instantiate_ns1__getExceptionReportResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getExceptionReportResponse ** p = (ns1__getExceptionReportResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getExceptionReportResponse, sizeof(ns1__getExceptionReportResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getExceptionReportResponse(struct soap *soap, ns1__getExceptionReportResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getExceptionReportResponse);
	if (soap_out_PointerTons1__getExceptionReportResponse(soap, tag?tag:"ns1:getExceptionReportResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getExceptionReportResponse ** SOAP_FMAC4 soap_get_PointerTons1__getExceptionReportResponse(struct soap *soap, ns1__getExceptionReportResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getExceptionReportResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getExceptionReport(struct soap *soap, ns1__getExceptionReport *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getExceptionReport))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getExceptionReport(struct soap *soap, const char *tag, int id, ns1__getExceptionReport *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getExceptionReport);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getExceptionReport ** SOAP_FMAC4 soap_in_PointerTons1__getExceptionReport(struct soap *soap, const char *tag, ns1__getExceptionReport **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getExceptionReport **)soap_malloc(soap, sizeof(ns1__getExceptionReport *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getExceptionReport *)soap_instantiate_ns1__getExceptionReport(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getExceptionReport ** p = (ns1__getExceptionReport **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getExceptionReport, sizeof(ns1__getExceptionReport), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getExceptionReport(struct soap *soap, ns1__getExceptionReport *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getExceptionReport);
	if (soap_out_PointerTons1__getExceptionReport(soap, tag?tag:"ns1:getExceptionReport", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getExceptionReport ** SOAP_FMAC4 soap_get_PointerTons1__getExceptionReport(struct soap *soap, ns1__getExceptionReport **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getExceptionReport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getDcpResponse(struct soap *soap, ns1__getDcpResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getDcpResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getDcpResponse(struct soap *soap, const char *tag, int id, ns1__getDcpResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getDcpResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getDcpResponse ** SOAP_FMAC4 soap_in_PointerTons1__getDcpResponse(struct soap *soap, const char *tag, ns1__getDcpResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getDcpResponse **)soap_malloc(soap, sizeof(ns1__getDcpResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getDcpResponse *)soap_instantiate_ns1__getDcpResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getDcpResponse ** p = (ns1__getDcpResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDcpResponse, sizeof(ns1__getDcpResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getDcpResponse(struct soap *soap, ns1__getDcpResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getDcpResponse);
	if (soap_out_PointerTons1__getDcpResponse(soap, tag?tag:"ns1:getDcpResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getDcpResponse ** SOAP_FMAC4 soap_get_PointerTons1__getDcpResponse(struct soap *soap, ns1__getDcpResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getDcpResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getDcp(struct soap *soap, ns1__getDcp *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getDcp))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getDcp(struct soap *soap, const char *tag, int id, ns1__getDcp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getDcp);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getDcp ** SOAP_FMAC4 soap_in_PointerTons1__getDcp(struct soap *soap, const char *tag, ns1__getDcp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getDcp **)soap_malloc(soap, sizeof(ns1__getDcp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getDcp *)soap_instantiate_ns1__getDcp(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getDcp ** p = (ns1__getDcp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getDcp, sizeof(ns1__getDcp), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getDcp(struct soap *soap, ns1__getDcp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getDcp);
	if (soap_out_PointerTons1__getDcp(soap, tag?tag:"ns1:getDcp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getDcp ** SOAP_FMAC4 soap_get_PointerTons1__getDcp(struct soap *soap, ns1__getDcp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getDcp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__sendTaskProcessResponse(struct soap *soap, ns1__sendTaskProcessResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__sendTaskProcessResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__sendTaskProcessResponse(struct soap *soap, const char *tag, int id, ns1__sendTaskProcessResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__sendTaskProcessResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__sendTaskProcessResponse ** SOAP_FMAC4 soap_in_PointerTons1__sendTaskProcessResponse(struct soap *soap, const char *tag, ns1__sendTaskProcessResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__sendTaskProcessResponse **)soap_malloc(soap, sizeof(ns1__sendTaskProcessResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__sendTaskProcessResponse *)soap_instantiate_ns1__sendTaskProcessResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__sendTaskProcessResponse ** p = (ns1__sendTaskProcessResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__sendTaskProcessResponse, sizeof(ns1__sendTaskProcessResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__sendTaskProcessResponse(struct soap *soap, ns1__sendTaskProcessResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__sendTaskProcessResponse);
	if (soap_out_PointerTons1__sendTaskProcessResponse(soap, tag?tag:"ns1:sendTaskProcessResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__sendTaskProcessResponse ** SOAP_FMAC4 soap_get_PointerTons1__sendTaskProcessResponse(struct soap *soap, ns1__sendTaskProcessResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__sendTaskProcessResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__sendTaskProcess(struct soap *soap, ns1__sendTaskProcess *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__sendTaskProcess))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__sendTaskProcess(struct soap *soap, const char *tag, int id, ns1__sendTaskProcess *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__sendTaskProcess);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__sendTaskProcess ** SOAP_FMAC4 soap_in_PointerTons1__sendTaskProcess(struct soap *soap, const char *tag, ns1__sendTaskProcess **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__sendTaskProcess **)soap_malloc(soap, sizeof(ns1__sendTaskProcess *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__sendTaskProcess *)soap_instantiate_ns1__sendTaskProcess(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__sendTaskProcess ** p = (ns1__sendTaskProcess **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__sendTaskProcess, sizeof(ns1__sendTaskProcess), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__sendTaskProcess(struct soap *soap, ns1__sendTaskProcess *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__sendTaskProcess);
	if (soap_out_PointerTons1__sendTaskProcess(soap, tag?tag:"ns1:sendTaskProcess", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__sendTaskProcess ** SOAP_FMAC4 soap_get_PointerTons1__sendTaskProcess(struct soap *soap, ns1__sendTaskProcess **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__sendTaskProcess(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getPackListResponse(struct soap *soap, ns1__getPackListResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getPackListResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getPackListResponse(struct soap *soap, const char *tag, int id, ns1__getPackListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getPackListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getPackListResponse ** SOAP_FMAC4 soap_in_PointerTons1__getPackListResponse(struct soap *soap, const char *tag, ns1__getPackListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getPackListResponse **)soap_malloc(soap, sizeof(ns1__getPackListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getPackListResponse *)soap_instantiate_ns1__getPackListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getPackListResponse ** p = (ns1__getPackListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getPackListResponse, sizeof(ns1__getPackListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getPackListResponse(struct soap *soap, ns1__getPackListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getPackListResponse);
	if (soap_out_PointerTons1__getPackListResponse(soap, tag?tag:"ns1:getPackListResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getPackListResponse ** SOAP_FMAC4 soap_get_PointerTons1__getPackListResponse(struct soap *soap, ns1__getPackListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getPackListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getPackList(struct soap *soap, ns1__getPackList *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getPackList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getPackList(struct soap *soap, const char *tag, int id, ns1__getPackList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getPackList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getPackList ** SOAP_FMAC4 soap_in_PointerTons1__getPackList(struct soap *soap, const char *tag, ns1__getPackList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getPackList **)soap_malloc(soap, sizeof(ns1__getPackList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getPackList *)soap_instantiate_ns1__getPackList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getPackList ** p = (ns1__getPackList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getPackList, sizeof(ns1__getPackList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getPackList(struct soap *soap, ns1__getPackList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getPackList);
	if (soap_out_PointerTons1__getPackList(soap, tag?tag:"ns1:getPackList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getPackList ** SOAP_FMAC4 soap_get_PointerTons1__getPackList(struct soap *soap, ns1__getPackList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getPackList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getTaskProcessReportResponse(struct soap *soap, ns1__getTaskProcessReportResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getTaskProcessReportResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getTaskProcessReportResponse(struct soap *soap, const char *tag, int id, ns1__getTaskProcessReportResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getTaskProcessReportResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getTaskProcessReportResponse ** SOAP_FMAC4 soap_in_PointerTons1__getTaskProcessReportResponse(struct soap *soap, const char *tag, ns1__getTaskProcessReportResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getTaskProcessReportResponse **)soap_malloc(soap, sizeof(ns1__getTaskProcessReportResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getTaskProcessReportResponse *)soap_instantiate_ns1__getTaskProcessReportResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getTaskProcessReportResponse ** p = (ns1__getTaskProcessReportResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getTaskProcessReportResponse, sizeof(ns1__getTaskProcessReportResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getTaskProcessReportResponse(struct soap *soap, ns1__getTaskProcessReportResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getTaskProcessReportResponse);
	if (soap_out_PointerTons1__getTaskProcessReportResponse(soap, tag?tag:"ns1:getTaskProcessReportResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getTaskProcessReportResponse ** SOAP_FMAC4 soap_get_PointerTons1__getTaskProcessReportResponse(struct soap *soap, ns1__getTaskProcessReportResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getTaskProcessReportResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getTaskProcessReport(struct soap *soap, ns1__getTaskProcessReport *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getTaskProcessReport))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getTaskProcessReport(struct soap *soap, const char *tag, int id, ns1__getTaskProcessReport *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getTaskProcessReport);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getTaskProcessReport ** SOAP_FMAC4 soap_in_PointerTons1__getTaskProcessReport(struct soap *soap, const char *tag, ns1__getTaskProcessReport **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getTaskProcessReport **)soap_malloc(soap, sizeof(ns1__getTaskProcessReport *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getTaskProcessReport *)soap_instantiate_ns1__getTaskProcessReport(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getTaskProcessReport ** p = (ns1__getTaskProcessReport **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getTaskProcessReport, sizeof(ns1__getTaskProcessReport), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getTaskProcessReport(struct soap *soap, ns1__getTaskProcessReport *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getTaskProcessReport);
	if (soap_out_PointerTons1__getTaskProcessReport(soap, tag?tag:"ns1:getTaskProcessReport", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__getTaskProcessReport ** SOAP_FMAC4 soap_get_PointerTons1__getTaskProcessReport(struct soap *soap, ns1__getTaskProcessReport **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getTaskProcessReport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SQLException(struct soap *soap, ns1__SQLException *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SQLException))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SQLException(struct soap *soap, const char *tag, int id, ns1__SQLException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SQLException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SQLException ** SOAP_FMAC4 soap_in_PointerTons1__SQLException(struct soap *soap, const char *tag, ns1__SQLException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SQLException **)soap_malloc(soap, sizeof(ns1__SQLException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SQLException *)soap_instantiate_ns1__SQLException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__SQLException ** p = (ns1__SQLException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SQLException, sizeof(ns1__SQLException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SQLException(struct soap *soap, ns1__SQLException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SQLException);
	if (soap_out_PointerTons1__SQLException(soap, tag?tag:"ns1:SQLException", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__SQLException ** SOAP_FMAC4 soap_get_PointerTons1__SQLException(struct soap *soap, ns1__SQLException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SQLException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TaskExceptionReport(struct soap *soap, ns1__TaskExceptionReport *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TaskExceptionReport))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TaskExceptionReport(struct soap *soap, const char *tag, int id, ns1__TaskExceptionReport *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TaskExceptionReport);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__TaskExceptionReport ** SOAP_FMAC4 soap_in_PointerTons1__TaskExceptionReport(struct soap *soap, const char *tag, ns1__TaskExceptionReport **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TaskExceptionReport **)soap_malloc(soap, sizeof(ns1__TaskExceptionReport *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TaskExceptionReport *)soap_instantiate_ns1__TaskExceptionReport(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__TaskExceptionReport ** p = (ns1__TaskExceptionReport **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TaskExceptionReport, sizeof(ns1__TaskExceptionReport), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TaskExceptionReport(struct soap *soap, ns1__TaskExceptionReport *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TaskExceptionReport);
	if (soap_out_PointerTons1__TaskExceptionReport(soap, tag?tag:"ns1:TaskExceptionReport", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TaskExceptionReport ** SOAP_FMAC4 soap_get_PointerTons1__TaskExceptionReport(struct soap *soap, ns1__TaskExceptionReport **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TaskExceptionReport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__dcpBean(struct soap *soap, ns1__dcpBean *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__dcpBean))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__dcpBean(struct soap *soap, const char *tag, int id, ns1__dcpBean *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__dcpBean);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__dcpBean ** SOAP_FMAC4 soap_in_PointerTons1__dcpBean(struct soap *soap, const char *tag, ns1__dcpBean **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__dcpBean **)soap_malloc(soap, sizeof(ns1__dcpBean *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__dcpBean *)soap_instantiate_ns1__dcpBean(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__dcpBean ** p = (ns1__dcpBean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__dcpBean, sizeof(ns1__dcpBean), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__dcpBean(struct soap *soap, ns1__dcpBean *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__dcpBean);
	if (soap_out_PointerTons1__dcpBean(soap, tag?tag:"ns1:dcpBean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__dcpBean ** SOAP_FMAC4 soap_get_PointerTons1__dcpBean(struct soap *soap, ns1__dcpBean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__dcpBean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TaskOper(struct soap *soap, ns1__TaskOper *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TaskOper))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TaskOper(struct soap *soap, const char *tag, int id, ns1__TaskOper *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TaskOper);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__TaskOper ** SOAP_FMAC4 soap_in_PointerTons1__TaskOper(struct soap *soap, const char *tag, ns1__TaskOper **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TaskOper **)soap_malloc(soap, sizeof(ns1__TaskOper *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TaskOper *)soap_instantiate_ns1__TaskOper(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__TaskOper ** p = (ns1__TaskOper **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TaskOper, sizeof(ns1__TaskOper), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TaskOper(struct soap *soap, ns1__TaskOper *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TaskOper);
	if (soap_out_PointerTons1__TaskOper(soap, tag?tag:"ns1:TaskOper", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TaskOper ** SOAP_FMAC4 soap_get_PointerTons1__TaskOper(struct soap *soap, ns1__TaskOper **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TaskOper(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TaskProcessReport(struct soap *soap, ns1__TaskProcessReport *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TaskProcessReport))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TaskProcessReport(struct soap *soap, const char *tag, int id, ns1__TaskProcessReport *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TaskProcessReport);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__TaskProcessReport ** SOAP_FMAC4 soap_in_PointerTons1__TaskProcessReport(struct soap *soap, const char *tag, ns1__TaskProcessReport **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TaskProcessReport **)soap_malloc(soap, sizeof(ns1__TaskProcessReport *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TaskProcessReport *)soap_instantiate_ns1__TaskProcessReport(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__TaskProcessReport ** p = (ns1__TaskProcessReport **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TaskProcessReport, sizeof(ns1__TaskProcessReport), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TaskProcessReport(struct soap *soap, ns1__TaskProcessReport *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TaskProcessReport);
	if (soap_out_PointerTons1__TaskProcessReport(soap, tag?tag:"ns1:TaskProcessReport", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TaskProcessReport ** SOAP_FMAC4 soap_get_PointerTons1__TaskProcessReport(struct soap *soap, ns1__TaskProcessReport **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TaskProcessReport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__dcpDetailBean(struct soap *soap, ns1__dcpDetailBean *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__dcpDetailBean))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__dcpDetailBean(struct soap *soap, const char *tag, int id, ns1__dcpDetailBean *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__dcpDetailBean);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__dcpDetailBean ** SOAP_FMAC4 soap_in_PointerTons1__dcpDetailBean(struct soap *soap, const char *tag, ns1__dcpDetailBean **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__dcpDetailBean **)soap_malloc(soap, sizeof(ns1__dcpDetailBean *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__dcpDetailBean *)soap_instantiate_ns1__dcpDetailBean(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__dcpDetailBean ** p = (ns1__dcpDetailBean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__dcpDetailBean, sizeof(ns1__dcpDetailBean), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__dcpDetailBean(struct soap *soap, ns1__dcpDetailBean *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__dcpDetailBean);
	if (soap_out_PointerTons1__dcpDetailBean(soap, tag?tag:"ns1:dcpDetailBean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__dcpDetailBean ** SOAP_FMAC4 soap_get_PointerTons1__dcpDetailBean(struct soap *soap, ns1__dcpDetailBean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__dcpDetailBean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TaskInfo(struct soap *soap, ns1__TaskInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TaskInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TaskInfo(struct soap *soap, const char *tag, int id, ns1__TaskInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TaskInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__TaskInfo ** SOAP_FMAC4 soap_in_PointerTons1__TaskInfo(struct soap *soap, const char *tag, ns1__TaskInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TaskInfo **)soap_malloc(soap, sizeof(ns1__TaskInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TaskInfo *)soap_instantiate_ns1__TaskInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__TaskInfo ** p = (ns1__TaskInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TaskInfo, sizeof(ns1__TaskInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TaskInfo(struct soap *soap, ns1__TaskInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TaskInfo);
	if (soap_out_PointerTons1__TaskInfo(soap, tag?tag:"ns1:TaskInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TaskInfo ** SOAP_FMAC4 soap_get_PointerTons1__TaskInfo(struct soap *soap, ns1__TaskInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TaskInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TaskProgress(struct soap *soap, ns1__TaskProgress *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TaskProgress))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TaskProgress(struct soap *soap, const char *tag, int id, ns1__TaskProgress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TaskProgress);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__TaskProgress ** SOAP_FMAC4 soap_in_PointerTons1__TaskProgress(struct soap *soap, const char *tag, ns1__TaskProgress **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TaskProgress **)soap_malloc(soap, sizeof(ns1__TaskProgress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TaskProgress *)soap_instantiate_ns1__TaskProgress(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__TaskProgress ** p = (ns1__TaskProgress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TaskProgress, sizeof(ns1__TaskProgress), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TaskProgress(struct soap *soap, ns1__TaskProgress *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TaskProgress);
	if (soap_out_PointerTons1__TaskProgress(soap, tag?tag:"ns1:TaskProgress", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__TaskProgress ** SOAP_FMAC4 soap_get_PointerTons1__TaskProgress(struct soap *soap, ns1__TaskProgress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TaskProgress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__dcpDetailBean(struct soap *soap, std::vector<ns1__dcpDetailBean * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__dcpDetailBean(struct soap *soap, const std::vector<ns1__dcpDetailBean * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns1__dcpDetailBean * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__dcpDetailBean(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__dcpDetailBean(struct soap *soap, const char *tag, int id, const std::vector<ns1__dcpDetailBean * >*a, const char *type)
{
	for (std::vector<ns1__dcpDetailBean * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__dcpDetailBean(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__dcpDetailBean * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__dcpDetailBean(struct soap *soap, const char *tag, std::vector<ns1__dcpDetailBean * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns1__dcpDetailBean *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__dcpDetailBean, SOAP_TYPE_std__vectorTemplateOfPointerTons1__dcpDetailBean, sizeof(ns1__dcpDetailBean), 1))
				break;
			if (!soap_in_PointerTons1__dcpDetailBean(soap, tag, NULL, "ns1:dcpDetailBean"))
				break;
		}
		else if (!soap_in_PointerTons1__dcpDetailBean(soap, tag, &n, "ns1:dcpDetailBean"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__dcpDetailBean(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__dcpDetailBean * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__dcpDetailBean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__dcpDetailBean(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__dcpDetailBean, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__dcpDetailBean * >);
		if (size)
			*size = sizeof(std::vector<ns1__dcpDetailBean * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns1__dcpDetailBean * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns1__dcpDetailBean * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns1__dcpDetailBean * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__dcpDetailBean(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__dcpDetailBean * > %p -> %p\n", q, p));
	*(std::vector<ns1__dcpDetailBean * >*)p = *(std::vector<ns1__dcpDetailBean * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__TaskInfo(struct soap *soap, std::vector<ns1__TaskInfo * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__TaskInfo(struct soap *soap, const std::vector<ns1__TaskInfo * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns1__TaskInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__TaskInfo(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__TaskInfo(struct soap *soap, const char *tag, int id, const std::vector<ns1__TaskInfo * >*a, const char *type)
{
	for (std::vector<ns1__TaskInfo * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__TaskInfo(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__TaskInfo * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__TaskInfo(struct soap *soap, const char *tag, std::vector<ns1__TaskInfo * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns1__TaskInfo *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__TaskInfo, SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaskInfo, sizeof(ns1__TaskInfo), 1))
				break;
			if (!soap_in_PointerTons1__TaskInfo(soap, tag, NULL, "ns1:TaskInfo"))
				break;
		}
		else if (!soap_in_PointerTons1__TaskInfo(soap, tag, &n, "ns1:TaskInfo"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__TaskInfo(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__TaskInfo * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__TaskInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__TaskInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaskInfo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__TaskInfo * >);
		if (size)
			*size = sizeof(std::vector<ns1__TaskInfo * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns1__TaskInfo * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns1__TaskInfo * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns1__TaskInfo * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__TaskInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__TaskInfo * > %p -> %p\n", q, p));
	*(std::vector<ns1__TaskInfo * >*)p = *(std::vector<ns1__TaskInfo * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__TaskProgress(struct soap *soap, std::vector<ns1__TaskProgress * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__TaskProgress(struct soap *soap, const std::vector<ns1__TaskProgress * >*a)
{
#ifndef WITH_NOIDREF
	for (std::vector<ns1__TaskProgress * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__TaskProgress(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__TaskProgress(struct soap *soap, const char *tag, int id, const std::vector<ns1__TaskProgress * >*a, const char *type)
{
	for (std::vector<ns1__TaskProgress * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__TaskProgress(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__TaskProgress * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__TaskProgress(struct soap *soap, const char *tag, std::vector<ns1__TaskProgress * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{	ns1__TaskProgress *n;
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__TaskProgress, SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaskProgress, sizeof(ns1__TaskProgress), 1))
				break;
			if (!soap_in_PointerTons1__TaskProgress(soap, tag, NULL, "ns1:TaskProgress"))
				break;
		}
		else if (!soap_in_PointerTons1__TaskProgress(soap, tag, &n, "ns1:TaskProgress"))
			break;
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__TaskProgress(soap, -1)))
			return NULL;
		a->push_back(n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__TaskProgress * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__TaskProgress(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__TaskProgress(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__TaskProgress, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__TaskProgress * >);
		if (size)
			*size = sizeof(std::vector<ns1__TaskProgress * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(std::vector<ns1__TaskProgress * >, n);
		if (size)
			*size = n * sizeof(std::vector<ns1__TaskProgress * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (std::vector<ns1__TaskProgress * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__TaskProgress(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__TaskProgress * > %p -> %p\n", q, p));
	*(std::vector<ns1__TaskProgress * >*)p = *(std::vector<ns1__TaskProgress * >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
