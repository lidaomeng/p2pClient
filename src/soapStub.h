/* soapStub.h
   Generated by gSOAP 2.8.14 from fctxt.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under ONE of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://tempuri.org/ns.xsd"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20814
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_ns1__TaskProcessReport
#define SOAP_TYPE_ns1__TaskProcessReport (8)
/* ns1:TaskProcessReport */
class SOAP_CMAC ns1__TaskProcessReport
{
public:
	std::string *peerID;	/* optional element of type xsd:string */
	std::vector<class ns1__TaskProgress * >taskProgressList;	/* required element of type ns1:TaskProgress */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique id SOAP_TYPE_ns1__TaskProcessReport */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__TaskProcessReport() { ns1__TaskProcessReport::soap_default(NULL); }
	virtual ~ns1__TaskProcessReport() { }
};
#endif

#ifndef SOAP_TYPE_ns1__TaskProgress
#define SOAP_TYPE_ns1__TaskProgress (9)
/* ns1:TaskProgress */
class SOAP_CMAC ns1__TaskProgress
{
public:
	class ns1__TaskInfo *taskInfo;	/* required element of type ns1:TaskInfo */
	int totalPeerCnt;	/* required element of type xsd:int */
	int connectingPeerCnt;	/* required element of type xsd:int */
	int connectedPeerCnt;	/* required element of type xsd:int */
	int downloadRate;	/* required element of type xsd:int */
	int uploadRate;	/* required element of type xsd:int */
	LONG64 downloaded;	/* required element of type xsd:long */
	LONG64 uploaded;	/* required element of type xsd:long */
	float percentCmp;	/* required element of type xsd:float */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 9; } /* = unique id SOAP_TYPE_ns1__TaskProgress */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__TaskProgress() { ns1__TaskProgress::soap_default(NULL); }
	virtual ~ns1__TaskProgress() { }
};
#endif

#ifndef SOAP_TYPE_ns1__TaskInfo
#define SOAP_TYPE_ns1__TaskInfo (10)
/* ns1:TaskInfo */
class SOAP_CMAC ns1__TaskInfo
{
public:
	std::string packageName;	/* required element of type xsd:string */
	std::string torrentUrl;	/* required element of type xsd:string */
	std::string filedownloadPath;	/* required element of type xsd:string */
	std::string *ftpAdress;	/* optional element of type xsd:string */
	std::string *baseStorageFtp;	/* optional element of type xsd:string */
	int State;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_ns1__TaskInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__TaskInfo() { ns1__TaskInfo::soap_default(NULL); }
	virtual ~ns1__TaskInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns1__abstractCollection
#define SOAP_TYPE_ns1__abstractCollection (11)
/* ns1:abstractCollection */
class SOAP_CMAC ns1__abstractCollection
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique id SOAP_TYPE_ns1__abstractCollection */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__abstractCollection() { ns1__abstractCollection::soap_default(NULL); }
	virtual ~ns1__abstractCollection() { }
};
#endif

#ifndef SOAP_TYPE_ns1__TaskOper
#define SOAP_TYPE_ns1__TaskOper (14)
/* ns1:TaskOper */
class SOAP_CMAC ns1__TaskOper
{
public:
	std::string *peerID;	/* optional element of type xsd:string */
	std::string *operType;	/* optional element of type xsd:string */
	std::vector<ns1__TaskInfo * >taskInfoList;	/* required element of type ns1:TaskInfo */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_ns1__TaskOper */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__TaskOper() { ns1__TaskOper::soap_default(NULL); }
	virtual ~ns1__TaskOper() { }
};
#endif

#ifndef SOAP_TYPE_ns1__dcpBean
#define SOAP_TYPE_ns1__dcpBean (15)
/* ns1:dcpBean */
class SOAP_CMAC ns1__dcpBean
{
public:
	std::vector<class ns1__dcpDetailBean * >record;	/* optional element of type ns1:dcpDetailBean */
	int resultCode;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_ns1__dcpBean */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__dcpBean() { ns1__dcpBean::soap_default(NULL); }
	virtual ~ns1__dcpBean() { }
};
#endif

#ifndef SOAP_TYPE_ns1__dcpDetailBean
#define SOAP_TYPE_ns1__dcpDetailBean (16)
/* ns1:dcpDetailBean */
class SOAP_CMAC ns1__dcpDetailBean
{
public:
	std::string *dcpTitle;	/* optional element of type xsd:string */
	std::string *ftpDownloadURL;	/* optional element of type xsd:string */
	std::string *uuid;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_ns1__dcpDetailBean */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__dcpDetailBean() { ns1__dcpDetailBean::soap_default(NULL); }
	virtual ~ns1__dcpDetailBean() { }
};
#endif

#ifndef SOAP_TYPE_ns1__TaskExceptionReport
#define SOAP_TYPE_ns1__TaskExceptionReport (17)
/* ns1:TaskExceptionReport */
class SOAP_CMAC ns1__TaskExceptionReport
{
public:
	std::string *peerID;	/* optional element of type xsd:string */
	ns1__TaskInfo *taskInfo;	/* optional element of type ns1:TaskInfo */
	std::string errID;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_ns1__TaskExceptionReport */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__TaskExceptionReport() { ns1__TaskExceptionReport::soap_default(NULL); }
	virtual ~ns1__TaskExceptionReport() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SQLException
#define SOAP_TYPE_ns1__SQLException (18)
/* ns1:SQLException */
class SOAP_CMAC ns1__SQLException
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_ns1__SQLException */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SQLException() { ns1__SQLException::soap_default(NULL); }
	virtual ~ns1__SQLException() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getTaskProcessReport
#define SOAP_TYPE_ns1__getTaskProcessReport (19)
/* ns1:getTaskProcessReport */
class SOAP_CMAC ns1__getTaskProcessReport
{
public:
	ns1__TaskProcessReport *arg0;	/* optional element of type ns1:TaskProcessReport */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_ns1__getTaskProcessReport */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getTaskProcessReport() { ns1__getTaskProcessReport::soap_default(NULL); }
	virtual ~ns1__getTaskProcessReport() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getTaskProcessReportResponse
#define SOAP_TYPE_ns1__getTaskProcessReportResponse (20)
/* ns1:getTaskProcessReportResponse */
class SOAP_CMAC ns1__getTaskProcessReportResponse
{
public:
	std::string *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_ns1__getTaskProcessReportResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getTaskProcessReportResponse() { ns1__getTaskProcessReportResponse::soap_default(NULL); }
	virtual ~ns1__getTaskProcessReportResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__sendTaskProcess
#define SOAP_TYPE_ns1__sendTaskProcess (21)
/* ns1:sendTaskProcess */
class SOAP_CMAC ns1__sendTaskProcess
{
public:
	ns1__TaskOper *arg0;	/* optional element of type ns1:TaskOper */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_ns1__sendTaskProcess */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__sendTaskProcess() { ns1__sendTaskProcess::soap_default(NULL); }
	virtual ~ns1__sendTaskProcess() { }
};
#endif

#ifndef SOAP_TYPE_ns1__sendTaskProcessResponse
#define SOAP_TYPE_ns1__sendTaskProcessResponse (22)
/* ns1:sendTaskProcessResponse */
class SOAP_CMAC ns1__sendTaskProcessResponse
{
public:
	ns1__TaskOper *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:TaskOper */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_ns1__sendTaskProcessResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__sendTaskProcessResponse() { ns1__sendTaskProcessResponse::soap_default(NULL); }
	virtual ~ns1__sendTaskProcessResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getPackList
#define SOAP_TYPE_ns1__getPackList (23)
/* ns1:getPackList */
class SOAP_CMAC ns1__getPackList
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_ns1__getPackList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getPackList() { ns1__getPackList::soap_default(NULL); }
	virtual ~ns1__getPackList() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getPackListResponse
#define SOAP_TYPE_ns1__getPackListResponse (24)
/* ns1:getPackListResponse */
class SOAP_CMAC ns1__getPackListResponse
{
public:
	std::string *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_ns1__getPackListResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getPackListResponse() { ns1__getPackListResponse::soap_default(NULL); }
	virtual ~ns1__getPackListResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getDcp
#define SOAP_TYPE_ns1__getDcp (25)
/* ns1:getDcp */
class SOAP_CMAC ns1__getDcp
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_ns1__getDcp */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getDcp() { ns1__getDcp::soap_default(NULL); }
	virtual ~ns1__getDcp() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getDcpResponse
#define SOAP_TYPE_ns1__getDcpResponse (26)
/* ns1:getDcpResponse */
class SOAP_CMAC ns1__getDcpResponse
{
public:
	ns1__dcpBean *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:dcpBean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_ns1__getDcpResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getDcpResponse() { ns1__getDcpResponse::soap_default(NULL); }
	virtual ~ns1__getDcpResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getExceptionReport
#define SOAP_TYPE_ns1__getExceptionReport (27)
/* ns1:getExceptionReport */
class SOAP_CMAC ns1__getExceptionReport
{
public:
	ns1__TaskExceptionReport *arg0;	/* optional element of type ns1:TaskExceptionReport */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_ns1__getExceptionReport */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getExceptionReport() { ns1__getExceptionReport::soap_default(NULL); }
	virtual ~ns1__getExceptionReport() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getExceptionReportResponse
#define SOAP_TYPE_ns1__getExceptionReportResponse (28)
/* ns1:getExceptionReportResponse */
class SOAP_CMAC ns1__getExceptionReportResponse
{
public:
	std::string *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ns1__getExceptionReportResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getExceptionReportResponse() { ns1__getExceptionReportResponse::soap_default(NULL); }
	virtual ~ns1__getExceptionReportResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__abstractList
#define SOAP_TYPE_ns1__abstractList (12)
/* ns1:abstractList */
class SOAP_CMAC ns1__abstractList : public ns1__abstractCollection
{
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_ns1__abstractList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__abstractList() { ns1__abstractList::soap_default(NULL); }
	virtual ~ns1__abstractList() { }
};
#endif

#ifndef SOAP_TYPE_ns1__arrayList
#define SOAP_TYPE_ns1__arrayList (13)
/* ns1:arrayList */
class SOAP_CMAC ns1__arrayList : public ns1__abstractList
{
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_ns1__arrayList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__arrayList() { ns1__arrayList::soap_default(NULL); }
	virtual ~ns1__arrayList() { }
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (44)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	ns1__SQLException *ns1__SQLException_;	/* optional element of type ns1:SQLException */
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 44; } /* = unique id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef SOAP_TYPE___ns1__getTaskProcessReport
#define SOAP_TYPE___ns1__getTaskProcessReport (51)
/* Operation wrapper: */
struct __ns1__getTaskProcessReport
{
public:
	ns1__getTaskProcessReport *ns1__getTaskProcessReport_;	/* optional element of type ns1:getTaskProcessReport */
public:
	int soap_type() const { return 51; } /* = unique id SOAP_TYPE___ns1__getTaskProcessReport */
};
#endif

#ifndef SOAP_TYPE___ns1__getPackList
#define SOAP_TYPE___ns1__getPackList (55)
/* Operation wrapper: */
struct __ns1__getPackList
{
public:
	ns1__getPackList *ns1__getPackList_;	/* optional element of type ns1:getPackList */
public:
	int soap_type() const { return 55; } /* = unique id SOAP_TYPE___ns1__getPackList */
};
#endif

#ifndef SOAP_TYPE___ns1__sendTaskProcess
#define SOAP_TYPE___ns1__sendTaskProcess (59)
/* Operation wrapper: */
struct __ns1__sendTaskProcess
{
public:
	ns1__sendTaskProcess *ns1__sendTaskProcess_;	/* optional element of type ns1:sendTaskProcess */
public:
	int soap_type() const { return 59; } /* = unique id SOAP_TYPE___ns1__sendTaskProcess */
};
#endif

#ifndef SOAP_TYPE___ns1__getDcp
#define SOAP_TYPE___ns1__getDcp (63)
/* Operation wrapper: */
struct __ns1__getDcp
{
public:
	ns1__getDcp *ns1__getDcp_;	/* optional element of type ns1:getDcp */
public:
	int soap_type() const { return 63; } /* = unique id SOAP_TYPE___ns1__getDcp */
};
#endif

#ifndef SOAP_TYPE___ns1__getExceptionReport
#define SOAP_TYPE___ns1__getExceptionReport (67)
/* Operation wrapper: */
struct __ns1__getExceptionReport
{
public:
	ns1__getExceptionReport *ns1__getExceptionReport_;	/* optional element of type ns1:getExceptionReport */
public:
	int soap_type() const { return 67; } /* = unique id SOAP_TYPE___ns1__getExceptionReport */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (68)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 68; } /* = unique id SOAP_TYPE_SOAP_ENV__Header */
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (69)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 69; } /* = unique id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (71)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 71; } /* = unique id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (72)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 72; } /* = unique id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Server-Side Operations                                                     *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 __ns1__getTaskProcessReport(struct soap*, ns1__getTaskProcessReport *ns1__getTaskProcessReport_, ns1__getTaskProcessReportResponse *ns1__getTaskProcessReportResponse_);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__getPackList(struct soap*, ns1__getPackList *ns1__getPackList_, ns1__getPackListResponse *ns1__getPackListResponse_);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__sendTaskProcess(struct soap*, ns1__sendTaskProcess *ns1__sendTaskProcess_, ns1__sendTaskProcessResponse *ns1__sendTaskProcessResponse_);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__getDcp(struct soap*, ns1__getDcp *ns1__getDcp_, ns1__getDcpResponse *ns1__getDcpResponse_);

SOAP_FMAC5 int SOAP_FMAC6 __ns1__getExceptionReport(struct soap*, ns1__getExceptionReport *ns1__getExceptionReport_, ns1__getExceptionReportResponse *ns1__getExceptionReportResponse_);

/******************************************************************************\
 *                                                                            *
 * Server-Side Skeletons to Invoke Service Operations                         *
 *                                                                            *
\******************************************************************************/

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__getTaskProcessReport(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__getPackList(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__sendTaskProcess(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__getDcp(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve___ns1__getExceptionReport(struct soap*);

/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stubs                                                     *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getTaskProcessReport(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getTaskProcessReport *ns1__getTaskProcessReport_, ns1__getTaskProcessReportResponse *ns1__getTaskProcessReportResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getPackList(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getPackList *ns1__getPackList_, ns1__getPackListResponse *ns1__getPackListResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__sendTaskProcess(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__sendTaskProcess *ns1__sendTaskProcess_, ns1__sendTaskProcessResponse *ns1__sendTaskProcessResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getDcp(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getDcp *ns1__getDcp_, ns1__getDcpResponse *ns1__getDcpResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getExceptionReport(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getExceptionReport *ns1__getExceptionReport_, ns1__getExceptionReportResponse *ns1__getExceptionReportResponse_);

#endif

/* End of soapStub.h */
